[{"protocol": "Aave", "timeStamp": "1645807072", "hash": "0x79e44f65dc1bfdbe2c0102070618385681a8170995656874a65e88c3c53b910c", "contractAddress": "0x2fbb0c60a41cb7ea5323071624dcead3d213d0fa", "SourceCode": ""}, {"protocol": "Aave", "timeStamp": "1618989068", "hash": "0xb195b148790175ac6e50f5f96d6cc01ef6b9c2b60502e14cff345e74bb3c64f6", "contractAddress": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "SourceCode": "pragma solidity ^0.4.24;\r\n\r\n// File: zos-lib/contracts/upgradeability/Proxy.sol\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy {\r\n  /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n  function () payable external {\r\n    _fallback();\r\n  }\r\n\r\n  /**\r\n   * @return The Address of the implementation.\r\n   */\r\n  function _implementation() internal view returns (address);\r\n\r\n  /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) internal {\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize)\r\n\r\n      // Call the implementation.\r\n      // out and outsize are 0 because we don't know the size yet.\r\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n      // Copy the returned data.\r\n      returndatacopy(0, 0, returndatasize)\r\n\r\n      switch result\r\n      // delegatecall returns 0 on error.\r\n      case 0 { revert(0, returndatasize) }\r\n      default { return(0, returndatasize) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n  function _willFallback() internal {\r\n  }\r\n\r\n  /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n  function _fallback() internal {\r\n    _willFallback();\r\n    _delegate(_implementation());\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n  /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   * @param implementation Address of the new implementation.\r\n   */\r\n  event Upgraded(address implementation);\r\n\r\n  /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @param _implementation Address of the initial implementation.\r\n   */\r\n  constructor(address _implementation) public {\r\n    assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\r\n\r\n    _setImplementation(_implementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current implementation.\r\n   * @return Address of the current implementation\r\n   */\r\n  function _implementation() internal view returns (address impl) {\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n    assembly {\r\n      impl := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the proxy to a new implementation.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    _setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the implementation address of the proxy.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _setImplementation(address newImplementation) private {\r\n    require(AddressUtils.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n    assembly {\r\n      sstore(slot, newImplementation)\r\n    }\r\n  }\r\n}\r\n\r\n// File: zos-lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol\r\n\r\n/**\r\n * @title AdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\r\n  /**\r\n   * @dev Emitted when the administration has been transferred.\r\n   * @param previousAdmin Address of the previous admin.\r\n   * @param newAdmin Address of the new admin.\r\n   */\r\n  event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n  /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n\r\n  /**\r\n   * @dev Modifier to check whether the `msg.sender` is the admin.\r\n   * If it is, it will run the function. Otherwise, it will delegate the call\r\n   * to the implementation.\r\n   */\r\n  modifier ifAdmin() {\r\n    if (msg.sender == _admin()) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Contract constructor.\r\n   * It sets the `msg.sender` as the proxy administrator.\r\n   * @param _implementation address of the initial implementation.\r\n   */\r\n  constructor(address _implementation) UpgradeabilityProxy(_implementation) public {\r\n    assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\r\n\r\n    _setAdmin(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n  function admin() external view ifAdmin returns (address) {\r\n    return _admin();\r\n  }\r\n\r\n  /**\r\n   * @return The address of the implementation.\r\n   */\r\n  function implementation() external view ifAdmin returns (address) {\r\n    return _implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of the proxy.\r\n   * Only the current admin can call this function.\r\n   * @param newAdmin Address to transfer proxy administration to.\r\n   */\r\n  function changeAdmin(address newAdmin) external ifAdmin {\r\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n    emit AdminChanged(_admin(), newAdmin);\r\n    _setAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be\r\n   * called, as described in\r\n   * https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n    require(address(this).call.value(msg.value)(data));\r\n  }\r\n\r\n  /**\r\n   * @return The admin slot.\r\n   */\r\n  function _admin() internal view returns (address adm) {\r\n    bytes32 slot = ADMIN_SLOT;\r\n    assembly {\r\n      adm := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the proxy admin.\r\n   * @param newAdmin Address of the new proxy admin.\r\n   */\r\n  function _setAdmin(address newAdmin) internal {\r\n    bytes32 slot = ADMIN_SLOT;\r\n\r\n    assembly {\r\n      sstore(slot, newAdmin)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal {\r\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\r\n    super._willFallback();\r\n  }\r\n}\r\n\r\n// File: contracts/FiatTokenProxy.sol\r\n\r\n/**\r\n* Copyright CENTRE SECZ 2018\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy \r\n* of this software and associated documentation files (the \"Software\"), to deal \r\n* in the Software without restriction, including without limitation the rights \r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \r\n* copies of the Software, and to permit persons to whom the Software is furnished to \r\n* do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all \r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN \r\n* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title FiatTokenProxy\r\n * @dev This contract proxies FiatToken calls and enables FiatToken upgrades\r\n*/ \r\ncontract FiatTokenProxy is AdminUpgradeabilityProxy {\r\n    constructor(address _implementation) public AdminUpgradeabilityProxy(_implementation) {\r\n    }\r\n}"}, {"protocol": "Aave", "timeStamp": "1618989041", "hash": "0x78ac126f269a48495e7bc062028dd03ded4897a0091fd9f1bda0e6eb9dc8641d", "contractAddress": "0x6b175474e89094c44da98b954eedeac495271d0f", "SourceCode": "// hevm: flattened sources of /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/dai.sol\r\npragma solidity =0.5.12;\r\n\r\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/lib.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity 0.5.12; */\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller,                              // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/dai.sol\r\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity 0.5.12; */\r\n\r\n/* import \"./lib.sol\"; */\r\n\r\ncontract Dai is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Dai/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- ERC20 Data ---\r\n    string  public constant name     = \"Dai Stablecoin\";\r\n    string  public constant symbol   = \"DAI\";\r\n    string  public constant version  = \"1\";\r\n    uint8   public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint)                      public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint)                      public nonces;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    // --- EIP712 niceties ---\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    constructor(uint256 chainId_) public {\r\n        wards[msg.sender] = 1;\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            chainId_,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // --- Token ---\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad, \"Dai/insufficient-balance\");\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"Dai/insufficient-allowance\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n        emit Transfer(src, dst, wad);\r\n        return true;\r\n    }\r\n    function mint(address usr, uint wad) external auth {\r\n        balanceOf[usr] = add(balanceOf[usr], wad);\r\n        totalSupply    = add(totalSupply, wad);\r\n        emit Transfer(address(0), usr, wad);\r\n    }\r\n    function burn(address usr, uint wad) external {\r\n        require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\r\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\r\n            require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\r\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\r\n        }\r\n        balanceOf[usr] = sub(balanceOf[usr], wad);\r\n        totalSupply    = sub(totalSupply, wad);\r\n        emit Transfer(usr, address(0), wad);\r\n    }\r\n    function approve(address usr, uint wad) external returns (bool) {\r\n        allowance[msg.sender][usr] = wad;\r\n        emit Approval(msg.sender, usr, wad);\r\n        return true;\r\n    }\r\n\r\n    // --- Alias ---\r\n    function push(address usr, uint wad) external {\r\n        transferFrom(msg.sender, usr, wad);\r\n    }\r\n    function pull(address usr, uint wad) external {\r\n        transferFrom(usr, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    // --- Approve by signature ---\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\r\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\r\n    {\r\n        bytes32 digest =\r\n            keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH,\r\n                                     holder,\r\n                                     spender,\r\n                                     nonce,\r\n                                     expiry,\r\n                                     allowed))\r\n        ));\r\n\r\n        require(holder != address(0), \"Dai/invalid-address-0\");\r\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\r\n        require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\r\n        require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\r\n        uint wad = allowed ? uint(-1) : 0;\r\n        allowance[holder][spender] = wad;\r\n        emit Approval(holder, spender, wad);\r\n    }\r\n}"}, {"protocol": "Aave", "timeStamp": "1609105924", "hash": "0x9262493a84670d7a7ff5929b6714adcc45af26b6c6dd73ba3803563c2c8e65e9", "contractAddress": "0x7d2768de32b0b80b7a3454c06bdac94a69ddc7a9", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './BaseImmutableAdminUpgradeabilityProxy.sol';\\nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableAdminUpgradeabilityProxy\\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\\n */\\ncontract InitializableImmutableAdminUpgradeabilityProxy is\\n  BaseImmutableAdminUpgradeabilityProxy,\\n  InitializableUpgradeabilityProxy\\n{\\n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {}\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title BaseImmutableAdminUpgradeabilityProxy\\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\\n * helps saving transactions costs\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  address immutable ADMIN;\\n\\n  constructor(address admin) public {\\n    ADMIN = admin;\\n  }\\n\\n  modifier ifAdmin() {\\n    if (msg.sender == ADMIN) {\\n      _;\\n    } else {\\n      _fallback();\\n    }\\n  }\\n\\n  /**\\n   * @return The address of the proxy admin.\\n   */\\n  function admin() external ifAdmin returns (address) {\\n    return ADMIN;\\n  }\\n\\n  /**\\n   * @return The address of the implementation.\\n   */\\n  function implementation() external ifAdmin returns (address) {\\n    return _implementation();\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function upgradeTo(address newImplementation) external ifAdmin {\\n    _upgradeTo(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\\n    external\\n    payable\\n    ifAdmin\\n  {\\n    _upgradeTo(newImplementation);\\n    (bool success, ) = newImplementation.delegatecall(data);\\n    require(success);\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal virtual override {\\n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');\\n    super._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './Proxy.sol';\\nimport '../contracts/Address.sol';\\n\\n/**\\n * @title BaseUpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract BaseUpgradeabilityProxy is Proxy {\\n  /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n  event Upgraded(address indexed implementation);\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n  /**\\n   * @dev Returns the current implementation.\\n   * @return impl Address of the current implementation\\n   */\\n  function _implementation() internal override view returns (address impl) {\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n    //solium-disable-next-line\\n    assembly {\\n      impl := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _upgradeTo(address newImplementation) internal {\\n    _setImplementation(newImplementation);\\n    emit Upgraded(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _setImplementation(address newImplementation) internal {\\n    require(\\n      Address.isContract(newImplementation),\\n      'Cannot set a proxy implementation to a non-contract address'\\n    );\\n\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n    //solium-disable-next-line\\n    assembly {\\n      sstore(slot, newImplementation)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\nabstract contract Proxy {\\n  /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n  fallback() external payable {\\n    _fallback();\\n  }\\n\\n  /**\\n   * @return The Address of the implementation.\\n   */\\n  function _implementation() internal virtual view returns (address);\\n\\n  /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n  function _delegate(address implementation) internal {\\n    //solium-disable-next-line\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize())\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize())\\n\\n      switch result\\n        // delegatecall returns 0 on error.\\n        case 0 {\\n          revert(0, returndatasize())\\n        }\\n        default {\\n          return(0, returndatasize())\\n        }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n  function _willFallback() internal virtual {}\\n\\n  /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n  function _fallback() internal {\\n    _willFallback();\\n    _delegate(_implementation());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableUpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\n * implementation and init data.\\n */\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  /**\\n   * @dev Contract initializer.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  function initialize(address _logic, bytes memory _data) public payable {\\n    require(_implementation() == address(0));\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\\n    _setImplementation(_logic);\\n    if (_data.length > 0) {\\n      (bool success, ) = _logic.delegatecall(_data);\\n      require(success);\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "Aave", "timeStamp": "1609105871", "hash": "0x21a7fa3c19be4efa184e53e04d8a79636f9d6c2fc6be9c27d9e3bcaa245caad8", "contractAddress": "0x2fbb0c60a41cb7ea5323071624dcead3d213d0fa", "SourceCode": ""}, {"protocol": "Aave", "timeStamp": "1609105798", "hash": "0x4ae18fd849de29ef549447237ea0452cba4d6229c32c047b003303f601311c6f", "contractAddress": "0xd533a949740bb3306d119cc777fa900ba034cd52", "SourceCode": "# @version 0.2.4\r\n\"\"\"\r\n@title Curve DAO Token\r\n@author Curve Finance\r\n@license MIT\r\n@notice ERC20 with piecewise-linear mining supply.\r\n@dev Based on the ERC-20 token standard as defined at\r\n     https://eips.ethereum.org/EIPS/eip-20\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\nevent UpdateMiningParameters:\r\n    time: uint256\r\n    rate: uint256\r\n    supply: uint256\r\n\r\nevent SetMinter:\r\n    minter: address\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowances: HashMap[address, HashMap[address, uint256]]\r\ntotal_supply: uint256\r\n\r\nminter: public(address)\r\nadmin: public(address)\r\n\r\n# General constants\r\nYEAR: constant(uint256) = 86400 * 365\r\n\r\n# Allocation:\r\n# =========\r\n# * shareholders - 30%\r\n# * emplyees - 3%\r\n# * DAO-controlled reserve - 5%\r\n# * Early users - 5%\r\n# == 43% ==\r\n# left for inflation: 57%\r\n\r\n# Supply parameters\r\nINITIAL_SUPPLY: constant(uint256) = 1_303_030_303\r\nINITIAL_RATE: constant(uint256) = 274_815_283 * 10 ** 18 / YEAR  # leading to 43% premine\r\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\r\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1189207115002721024  # 2 ** (1/4) * 1e18\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nINFLATION_DELAY: constant(uint256) = 86400\r\n\r\n# Supply variables\r\nmining_epoch: public(int128)\r\nstart_epoch_time: public(uint256)\r\nrate: public(uint256)\r\n\r\nstart_epoch_supply: uint256\r\n\r\n\r\n@external\r\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _name Token full name\r\n    @param _symbol Token symbol\r\n    @param _decimals Number of decimals for token\r\n    \"\"\"\r\n    init_supply: uint256 = INITIAL_SUPPLY * 10 ** _decimals\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = _decimals\r\n    self.balanceOf[msg.sender] = init_supply\r\n    self.total_supply = init_supply\r\n    self.admin = msg.sender\r\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n\r\n    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_REDUCTION_TIME\r\n    self.mining_epoch = -1\r\n    self.rate = 0\r\n    self.start_epoch_supply = init_supply\r\n\r\n\r\n@internal\r\ndef _update_mining_parameters():\r\n    \"\"\"\r\n    @dev Update mining rate and supply at the start of the epoch\r\n         Any modifying mining call must also call this\r\n    \"\"\"\r\n    _rate: uint256 = self.rate\r\n    _start_epoch_supply: uint256 = self.start_epoch_supply\r\n\r\n    self.start_epoch_time += RATE_REDUCTION_TIME\r\n    self.mining_epoch += 1\r\n\r\n    if _rate == 0:\r\n        _rate = INITIAL_RATE\r\n    else:\r\n        _start_epoch_supply += _rate * RATE_REDUCTION_TIME\r\n        self.start_epoch_supply = _start_epoch_supply\r\n        _rate = _rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n\r\n    self.rate = _rate\r\n\r\n    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\r\n\r\n\r\n@external\r\ndef update_mining_parameters():\r\n    \"\"\"\r\n    @notice Update mining rate and supply at the start of the epoch\r\n    @dev Callable by any address, but only once per epoch\r\n         Total supply becomes slightly larger if this function is called late\r\n    \"\"\"\r\n    assert block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME  # dev: too soon!\r\n    self._update_mining_parameters()\r\n\r\n\r\n@external\r\ndef start_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the current mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time\r\n    else:\r\n        return _start_epoch_time\r\n\r\n\r\n@external\r\ndef future_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the next mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the next epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time + RATE_REDUCTION_TIME\r\n    else:\r\n        return _start_epoch_time + RATE_REDUCTION_TIME\r\n\r\n\r\n@internal\r\n@view\r\ndef _available_supply() -> uint256:\r\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\r\n\r\n\r\n@external\r\n@view\r\ndef available_supply() -> uint256:\r\n    \"\"\"\r\n    @notice Current number of tokens in existence (claimed or unclaimed)\r\n    \"\"\"\r\n    return self._available_supply()\r\n\r\n\r\n@external\r\n@view\r\ndef mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice How much supply is mintable from start timestamp till end timestamp\r\n    @param start Start of the time interval (timestamp)\r\n    @param end End of the time interval (timestamp)\r\n    @return Tokens mintable from `start` till `end`\r\n    \"\"\"\r\n    assert start <= end  # dev: start > end\r\n    to_mint: uint256 = 0\r\n    current_epoch_time: uint256 = self.start_epoch_time\r\n    current_rate: uint256 = self.rate\r\n\r\n    # Special case if end is in future (not yet minted) epoch\r\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\r\n        current_epoch_time += RATE_REDUCTION_TIME\r\n        current_rate = current_rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n\r\n    assert end <= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\r\n\r\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\r\n        if end >= current_epoch_time:\r\n            current_end: uint256 = end\r\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\r\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\r\n\r\n            current_start: uint256 = start\r\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\r\n                break  # We should never get here but what if...\r\n            elif current_start < current_epoch_time:\r\n                current_start = current_epoch_time\r\n\r\n            to_mint += current_rate * (current_end - current_start)\r\n\r\n            if start >= current_epoch_time:\r\n                break\r\n\r\n        current_epoch_time -= RATE_REDUCTION_TIME\r\n        current_rate = current_rate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\r\n        assert current_rate <= INITIAL_RATE  # This should never happen\r\n\r\n    return to_mint\r\n\r\n\r\n@external\r\ndef set_minter(_minter: address):\r\n    \"\"\"\r\n    @notice Set the minter address\r\n    @dev Only callable once, when minter has not yet been set\r\n    @param _minter Address of the minter\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\r\n    self.minter = _minter\r\n    log SetMinter(_minter)\r\n\r\n\r\n@external\r\ndef set_admin(_admin: address):\r\n    \"\"\"\r\n    @notice Set the new admin.\r\n    @dev After all is set up, admin only can change the token name\r\n    @param _admin New admin address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.admin = _admin\r\n    log SetAdmin(_admin)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @notice Total number of tokens in existence.\r\n    \"\"\"\r\n    return self.total_supply\r\n\r\n\r\n@external\r\n@view\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    \"\"\"\r\n    @notice Check the amount of tokens that an owner allowed to a spender\r\n    @param _owner The address which owns the funds\r\n    @param _spender The address which will spend the funds\r\n    @return uint256 specifying the amount of tokens still available for the spender\r\n    \"\"\"\r\n    return self.allowances[_owner][_spender]\r\n\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer `_value` tokens from `msg.sender` to `_to`\r\n    @dev Vyper does not allow underflows, so the subtraction in\r\n         this function will revert on an insufficient balance\r\n    @param _to The address to transfer to\r\n    @param _value The amount to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @notice Transfer `_value` tokens from `_from` to `_to`\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n     @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    # NOTE: vyper does not allow underflows\r\n    #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log Transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\r\n    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\r\n        to mitigate the potential race condition described here:\r\n        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds\r\n    @param _value The amount of tokens to be spent\r\n    @return bool success\r\n    \"\"\"\r\n    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef mint(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Mint `_value` tokens and assign them to `_to`\r\n    @dev Emits a Transfer event originating from 0x00\r\n    @param _to The account that will receive the created tokens\r\n    @param _value The amount that will be created\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.minter  # dev: minter only\r\n    assert _to != ZERO_ADDRESS  # dev: zero address\r\n\r\n    if block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n\r\n    _total_supply: uint256 = self.total_supply + _value\r\n    assert _total_supply <= self._available_supply()  # dev: exceeds allowable mint amount\r\n    self.total_supply = _total_supply\r\n\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(ZERO_ADDRESS, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef burn(_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Burn `_value` tokens belonging to `msg.sender`\r\n    @dev Emits a Transfer event with a destination of 0x00\r\n    @param _value The amount that will be burned\r\n    @return bool success\r\n    \"\"\"\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.total_supply -= _value\r\n\r\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef set_name(_name: String[64], _symbol: String[32]):\r\n    \"\"\"\r\n    @notice Change the token name and symbol to `_name` and `_symbol`\r\n    @dev Only callable by the admin account\r\n    @param _name New token name\r\n    @param _symbol New token symbol\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Only admin is allowed to change name\"\r\n    self.name = _name\r\n    self.symbol = _symbol"}, {"protocol": "Aave", "timeStamp": "1609105730", "hash": "0x684ec9a0c02fde789fe12c3633bd1a5ada6a96c043ee41aab9ba9a5440fd9174", "contractAddress": "0x7a250d5630b4cf539739df2c5dacb4c659f2488d", "SourceCode": "pragma solidity =0.6.6;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract UniswapV2Router02 is IUniswapV2Router02 {\r\n    using SafeMath for uint;\r\n\r\n    address public immutable override factory;\r\n    address public immutable override WETH;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) public {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal virtual returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IUniswapV2Pair(pair).mint(to);\r\n    }\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        assert(IWETH(WETH).transfer(pair, amountETH));\r\n        liquidity = IUniswapV2Pair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\r\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\r\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountToken, uint amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n        );\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            { // scope to avoid stack too deep errors\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        uint amountIn = msg.value;\r\n        IWETH(WETH).deposit{value: amountIn}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\r\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountOut)\r\n    {\r\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountIn)\r\n    {\r\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint amountIn, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint amountOut, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n    }\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}"}, {"protocol": "Aave", "timeStamp": "1609019048", "hash": "0x9601d3facda848c16eb5f82d6f497d3d81b2786983217346bd83ac2d55e06050", "contractAddress": "0xec568fffba86c094cf06b22134b23074dfe2252c", "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"}, {"protocol": "Aave", "timeStamp": "1608888933", "hash": "0x888d85ca7e89cfc89d5c723df1bf713a23aaf17b9ddb66ac900891d13621f388", "contractAddress": "0x111111111117dc0aa78b770fa6a738034120c302", "SourceCode": "/*\r\n                                        ,\u2584m    ,\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2556\r\n                                    \u2553\u2584\u2593\u2588\u2588\u258c\u2553\u2584\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2514\r\n                                  \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2584\u2584\u2584,\r\n              \u2553,              ,\u2584\u2584\u2588\u2588\u2588\u2593\u2563\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2584,\r\n               \u2580\u2588\u2593\u2584\u2565       x\u0398\u2559\u2560\u2560\u2588\u2588\u2588\u2593\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u2593\u2580  \u2590\u2588\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u258c\u2556\r\n                 \u2559\u2588\u2588\u2588\u2588\u2593\u2584Q  ,\u03c6\u2592\u2592\u2592\u2588\u2588\u2588\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u2593\u2593\u2580  \u2555 \u2590\u2588\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2584\r\n                   \u2559\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2584\u2584\u2592\u2592\u2588\u2588\u2588\u256c\u256c\u2563\u2588\u2588\u2588\u2588\u256c\u256c\u2563\u2588\u2588\u2588\u256c\u256c\u2593\u2588\u2588\u2588\u2580  \u2584\u2588\u2310 \u256b\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u258c\r\n                   /  \u2580\u2588\u2588\u2588\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u256c\u2588\u2588\u2588\u2593\u2588\u2588\u2588\u2588\u2580  \u2584\u2588\u2588\u2580 \u2554\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2588\u2588\u2584\r\n                 \u2584\u2559     \u2559\u2588\u2588\u2593\u2584\u2559\u2580\u2593\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580  \u00aa\u2580\u2580\u2514 ,\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\r\n               ,\u2593   \u2553\u2560\u2592\u2265  \u2559\u2593\u2588\u2588\u2593\u2556 \u2514\u2580\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2588\u2588\u2593\u2559       \u2584\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\r\n              \u2584\u2588   \u2554\u2592\u2592\u2592\u2592\"   \u2514\u2580\u2588\u2588\u2588\u258c,  \u2559\u2588\u2588\u2588\u2588\u2580         ~\u03a6\u2593\u2588\u2588\u2593\u2580\u2580\u2569\u2593\u2588\u2588\u2559\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u258c\r\n             \u2593\u2588   \u03c6\u2592\u2592\u2592\u2559    \u2554\u2554  \u2559\u2588\u2588\u2588\u2588\u2584\u2584\u2588\u2588\u2588\u2580          ,         \u2588\u2588\u258c   \u2559\u2593\u2588\u2588\u2588\u2588\u2588\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2593\u2514\u2580b\r\n            \u2593\u2588   \u2554\u2592\u2592\u2592`    \u03c6\u2592\u2592\u2592\u207f  \u256b\u2588\u2588\u2588\u2588\u2588\u2588`         ,\u258c          \u256b\u2588\u2588      \u2559\u2588\u2588\u2588\u2588\u2588\u256c\u256c\u256c\u256c\u2588\u2588\u2593\r\n           \u256b\u2588\u2500  .\u2592\u2592\u2592     \u2560\u2592\u2592\u255a   ]\u2588\u2588\u2588\u2588\u2588\u2588\u00ac         \u2593\u2588            \u2588\u2588\u258c       \u2514\u2593\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u2588\u2588\u2593\r\n          \u2590\u2588\u258c   \u2560\u2592\u2592     \u03c6\u2592\u2592\"    \u2590\u2588\u2588\u2588\u2588\u2588\u2500        \u2593\u2588\u2580\u2588\u2588\u258c          \u2588\u2588\u2588       \u256c \u2514\u2588\u2588\u2588\u2588\u256c\u256c\u256c\u2588\u2588\u258c\r\n          \u2588\u2588   ]\u2592\u2592\u2310    .\u2592\u2592       \u2593\u2588\u2588\u2588\u2588       \u2584\u2588\u2580\u2524\u2591\u2590\u2588\u2588        \u2553\u2588\u2588\u2588\u2580      /\u256b\u2592\u03b5 \u2559\u2588\u2588\u2588\u256c\u256c\u2563\u2588\u2588\r\n         \u2590\u2588\u2588   \u255a\u2592\u255a     \u2560\u2592        \u2551\u2588\u2588\u2588\u2588\u2310 \u255f\u2584,\u2593\u2588\u2593\u2524Q\u2584\u2593\u2588\u2580        \u2584\u2580\u2593\u2593`      \u2553\u2592\u2593\u258c\u2592\u2554 \u2514\u2588\u2588\u2588\u256c\u256c\u2588\u2588\u258c\r\n         \u2593\u2588\u258c   \u2592\u2592      \u2592\u2559        \u2588\u2588\u2588\u2588\u2588\u2588 \u256b\u2588\u2588\u2588\u2588\u2593\u2580\u2580\u2559          \u2593         ,\u03c6\u2592\u2551\u2588\u258c\u2592\u2592\u2265  \u2588\u2588\u2588\u256c\u2593\u2588\u2588\r\n         \u2588\u2588\u258c   \u2592\u2592      \u2592        \u2590\u2588\u2588\u2588\u2559\u2588\u2588b \u2514\u2559          \u2584\u00c6R\u2580\u2580\u2580       \u2553\u03c6\u2560\u2592\u2592\u2584\u2588\u2588\u2592\u2592\u2592\u2592  \u2559\u2588\u2588\u2588\u2563\u2588\u2588\r\n         \u2588\u2588\u258c   \u2592\u0393      \u2559        \u2588\u2588\u2588\u258c \u255f\u2588            ,\u2593,\u03c6\u03c6\u2560\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2584\u2593\u2588\u2588\u2588\u2580\u2592\u2592\u2592\u2592\u2560  \u2593\u2588\u2588\u2593\u2588\u2588\u2500\r\n         \u2588\u2588\u258c   \u255a\u2310      \u2310       \u2593\u2588\u2588\u2588               \u2554\u258c\u00ab\u2592\u2592\u2592\u2592\u2584\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2592\u2592\u2592\u2592\u2592\u2592  \u2590\u2588\u2588\u2588\u2588\u2588\r\n         \u2588\u2588\u2588   '\u03b5             ]\u2588\u2588\u2588\u2310             \u2553\u2584\u2580\u03c6\u2592\u2592\u2592\u2584\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2580\u256c\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592   \u2588\u2588\u2588\u2588\u2588\r\n         \u256b\u2588\u2588\u00b5   \u03c6             \u2588\u2588\u2588\u258c        \u2553\u2554\u03c6\u2560\u2592\u2591\u2593,\u2560\u2592\u2592\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580  \u2559\u2588\u2593\u2584`\u2559\u2560\u2592\u2592\u2592\u2592\u2592\u2592\u2592   \u2588\u2588\u2588\u2588\u2588\r\n         \u2514\u2588\u2588\u2588                \u256b\u2588\u2588\u2588       ,\u2560\u2592\u2592\u2584\u2593\u2593\u2588\u2593\u2593\u2593\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580      \u2593\u2588\u2588\u258c,`\u255a\u2592\u2592\u2592\u2592\u2592  ]\u2588\u2588\u2588\u2588\u258c\r\n          \u2593\u2588\u2588\u258c              \u2593\u2588\u2588\u2588\u00ac   \u2554  \u03c6\u2592\u2592\u2592\u2560\u2560\u2560\u2560\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2559         \u2588\u2588\u2588\u2588\u258c  \u255a\u2592\u2592\u2559  \u2593\u2588\u2588\u2588\u2588\r\n           \u2588\u2588\u2588\u2584           \u2584\u2588\u2588\u2588\u2580  \u2552  \u2560\u2265\u2560\u2592\u2592\u2592\u2591\u2584\u2593\u258c\u2568\u255a\u2592\u255a\u2593\u2588\u2588\u2588\u2588\u2588\u2514           \u2551\u2588\u2588\u2588\u2588\u2588  \u2514\u2592  ]\u2588\u2588\u2588\u2588`\r\n           \u2514\u2588\u2588\u2588\u258c         \u2593\u2588\u2588\u2588\u2559  \u2593\u2584  \u2560\u2592\u2592\u2592\u2592\u2592\u2588\u2588\u2559\u2559\u2593\u2593 \u2592\u2592\u2588\u2588\u2588\u2588             \u2590\u2588\u2588\u2588\u2588\u2588\u2588    ,\u2588\u2588\u2588\u2588\u2568\r\n            \u2514\u2588\u2588\u2588\u258c       \u2590\u2588\u2588\u2588  \u2554\u2588\u2588\u2588  \u2560\u2592\u2592\u2592\u2592\u256b\u2588\u2310,\u2584\u2593\u2593 \u2592\u2592\u2593\u2588\u2588\u258c             \u256b\u2588\u2588\u2588\u2588\u2588\u2588\u2593  \u2553\u2588\u2588\u2588\u2588\u2580\r\n              \u2588\u2588\u2588\u2588\u00b5      \u2588\u2588\u2588b  \u2580\u2559  \u03c6\u2592\u2592\u2592\u2592\u2584\u2588\u2588\u2593\u2593\u2560\u03c6\u2560\u2592\u2592\u2593\u2588\u2588\u2588             ]\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310\u2584\u2588\u2588\u2588\u2588\u2518\r\n               \u2580\u2588\u2588\u2588\u258c     \u256b\u2588\u2588\u2588  .\u2554\u03c6\u2592\u2592\u2592\u2592\u2592\u2593\u2588\u2593\u256c\u2591\u2592\u2592\u2584\u2593\u2588\u2588\u2588\u2588\u2580              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\r\n                \u2559\u2588\u2588\u2588\u2588\u258c    \u2593\u2588\u2588\u2593\u2584,   \u2590\u2593\u2593\u2588\u2588\u2584\u2584\u2584\u2584\u2593\u2588\u2588\u2588\u2588\u2580\u2514              ,\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\r\n                  \u2559\u2588\u2588\u2588\u2588\u258c\u00b5  \u2559\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2580                 \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\r\n                    \u2559\u2588\u2588\u2588\u2588\u2588\u2584,   \u2514\u2559\u2559\u2580\u2580\u2559                         \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\r\n                      \u2514\u2580\u2588\u2588\u2588\u2588\u2588\u2593\u2584                            \u2584\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2559\r\n                         \u2559\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2584\u2584,                 ,\u2584\u2593\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2559\r\n                             \u2559\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2514\r\n                                 \u2559\u2559\u2580\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2559\r\n                                        \u2514\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2559\u2559\u2514\r\n\r\n         \u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\r\n        \u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551    \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\r\n        \u255a\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551       \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\r\n         \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551       \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\r\n         \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551       \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\r\n         \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d       \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\r\n*/\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\r\n\r\n        _approve(account, _msgSender(), decreasedAllowance);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: contracts/IERC20Permit.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n// A copy of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecc66719bd7681ed4eb8bf406f89a7408569ba9b/contracts/drafts/IERC20Permit.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// File: contracts/ECDSA.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n// A copy of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecc66719bd7681ed4eb8bf406f89a7408569ba9b/contracts/cryptography/ECDSA.sol\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature s value\");\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature v value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/EIP712.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n// A copy of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecc66719bd7681ed4eb8bf406f89a7408569ba9b/contracts/drafts/EIP712.sol\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\r\n *\r\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\r\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\r\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\r\n *\r\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\r\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\r\n * ({_hashTypedDataV4}).\r\n *\r\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\r\n * the chain id to protect against replay attacks on an eventual fork of the chain.\r\n *\r\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\r\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\r\n */\r\nabstract contract EIP712 {\r\n    /* solhint-disable var-name-mixedcase */\r\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\r\n    // invalidate the cached domain separator if the chain id changes.\r\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\r\n    uint256 private immutable _CACHED_CHAIN_ID;\r\n\r\n    bytes32 private immutable _HASHED_NAME;\r\n    bytes32 private immutable _HASHED_VERSION;\r\n    bytes32 private immutable _TYPE_HASH;\r\n    /* solhint-enable var-name-mixedcase */\r\n\r\n    /**\r\n     * @dev Initializes the domain separator and parameter caches.\r\n     *\r\n     * The meaning of `name` and `version` is specified in\r\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\r\n     *\r\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\r\n     * - `version`: the current major version of the signing domain.\r\n     *\r\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\r\n     * contract upgrade].\r\n     */\r\n    constructor(string memory name, string memory version) internal {\r\n        bytes32 hashedName = keccak256(bytes(name));\r\n        bytes32 hashedVersion = keccak256(bytes(version));\r\n        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n        _HASHED_NAME = hashedName;\r\n        _HASHED_VERSION = hashedVersion;\r\n        _CACHED_CHAIN_ID = _getChainId();\r\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\r\n        _TYPE_HASH = typeHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator for the current chain.\r\n     */\r\n    function _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (_getChainId() == _CACHED_CHAIN_ID) {\r\n            return _CACHED_DOMAIN_SEPARATOR;\r\n        } else {\r\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                typeHash,\r\n                name,\r\n                version,\r\n                _getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\r\n     * function returns the hash of the fully encoded EIP712 message for this domain.\r\n     *\r\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\r\n     *\r\n     * ```solidity\r\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\r\n     *     keccak256(\"Mail(address to,string contents)\"),\r\n     *     mailTo,\r\n     *     keccak256(bytes(mailContents))\r\n     * )));\r\n     * address signer = ECDSA.recover(digest, signature);\r\n     * ```\r\n     */\r\n    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\r\n    }\r\n\r\n    function _getChainId() private pure returns (uint256 chainId) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ERC20Permit.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// An adapted copy of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecc66719bd7681ed4eb8bf406f89a7408569ba9b/contracts/drafts/ERC20Permit.sol\r\n\r\n/**\r\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\r\n    using Counters for Counters.Counter;\r\n\r\n    mapping (address => Counters.Counter) private _nonces;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-permit}.\r\n     */\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\r\n\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                _PERMIT_TYPEHASH,\r\n                owner,\r\n                spender,\r\n                value,\r\n                _nonces[owner].current(),\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 hash = _hashTypedDataV4(structHash);\r\n\r\n        address signer = ECDSA.recover(hash, v, r, s);\r\n        require(signer == owner, \"ERC20Permit: invalid signature\");\r\n\r\n        _nonces[owner].increment();\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-nonces}.\r\n     */\r\n    function nonces(address owner) public view override returns (uint256) {\r\n        return _nonces[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\r\n        return _domainSeparatorV4();\r\n    }\r\n}\r\n\r\n// File: contracts/OneInch.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract OneInch is ERC20Permit, ERC20Burnable, Ownable {\r\n    constructor(address _owner) public ERC20(\"1INCH Token\", \"1INCH\") EIP712(\"1INCH Token\", \"1\") {\r\n        _mint(_owner, 1.5e9 ether);\r\n        transferOwnership(_owner);\r\n    }\r\n\r\n    function mint(address to, uint256 amount) external onlyOwner {\r\n        _mint(to, amount);\r\n    }\r\n}"}, {"protocol": "Aave", "timeStamp": "1608887960", "hash": "0x0c8d24caea452fd09c3981611c096ed38169d00496b264813586d54aa601d690", "contractAddress": "0xe295ad71242373c37c5fda7b57f26f9ea1088afe", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/zumzoom/Projects/1inch/merkle-distributor/contracts/MerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.6.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\nimport \\\"./interfaces/IMerkleDistributor.sol\\\";\\n\\ncontract MerkleDistributor is IMerkleDistributor {\\n    address public immutable override token;\\n    bytes32 public immutable override merkleRoot;\\n\\n    // This is a packed array of booleans.\\n    mapping(uint256 => uint256) private claimedBitMap;\\n\\n    constructor(address token_, bytes32 merkleRoot_) public {\\n        token = token_;\\n        merkleRoot = merkleRoot_;\\n    }\\n\\n    function isClaimed(uint256 index) public view override returns (bool) {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    function _setClaimed(uint256 index) private {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\n    }\\n\\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\\n        require(!isClaimed(index), 'MerkleDistributor: Drop already claimed.');\\n\\n        // Verify the merkle proof.\\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor: Invalid proof.');\\n\\n        // Mark it claimed and send the token.\\n        _setClaimed(index);\\n        require(IERC20(token).transfer(account, amount), 'MerkleDistributor: Transfer failed.');\\n\\n        emit Claimed(index, account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/merkle-distributor/contracts/interfaces/IMerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\n// Allows anyone to claim a token if they exist in a merkle root.\\ninterface IMerkleDistributor {\\n    // Returns the address of the token distributed by this contract.\\n    function token() external view returns (address);\\n    // Returns the merkle root of the merkle tree containing account balances available to claim.\\n    function merkleRoot() external view returns (bytes32);\\n    // Returns true if the index has been marked claimed.\\n    function isClaimed(uint256 index) external view returns (bool);\\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external;\\n\\n    // This event is triggered whenever a call to #claim succeeds.\\n    event Claimed(uint256 index, address account, uint256 amount);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"}][{"protocol": "Aave", "timeStamp": "1621811192", "hash": "0x459675c20ffae407d370d116f49bce8e2f19f7427027bede1cc096c9619f2413", "contractAddress": "0x47b24fdf2f8ec7b72ac879b124f90f3fc53b51ca", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/misc/RankedAuctionWETHGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {IRankedAuction} from '../interfaces/IRankedAuction.sol';\\nimport {WETHGatewayBase} from './WETHGatewayBase.sol';\\n\\n/**\\n * @title RankedAuctionWETHGateway contract\\n *\\n * @author Aito\\n * @notice Simple gateway to allow bidding in Aito ranked auctions denominated in WETH using ETH.\\n */\\ncontract RankedAuctionWETHGateway is WETHGatewayBase {\\n\\n    constructor(address weth) WETHGatewayBase(weth){}\\n\\n    /**\\n     * @notice Bids using the caller's ETH onBehalfOf the given address.\\n     *\\n     * @param auction The auction address to query an auction to bid on.\\n     * @param auctionId The ranked auction ID to bid on.\\n     * @param onBehalfOf The address to bid on behalf of.\\n     * @param amount The amount to bid.\\n     */\\n    function bidWithEth(\\n        address auction,\\n        uint256 auctionId,\\n        address onBehalfOf,\\n        uint256 amount\\n    ) external payable {\\n        uint256 WETHBefore = WETH.balanceOf(address(this));\\n        WETH.deposit{value: msg.value}();\\n        IRankedAuction(auction).bid(auctionId, onBehalfOf, amount);\\n        uint256 WETHAfter = WETH.balanceOf(address(this));\\n        if (WETHAfter > WETHBefore) {\\n            uint256 diff = WETHAfter - WETHBefore;\\n            WETH.withdraw(diff);\\n            _safeTransferETH(msg.sender, diff);\\n        }\\n        require(WETH.balanceOf(address(this)) == WETHBefore, \\\"RankedAuctionWETHGateway: Invalid WETH After\\\");\\n    }\\n\\n    receive() external payable {\\n        require(msg.sender == address(WETH), \\\"RankedAuctionWETHGateway: Not WETH address\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRankedAuction.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\ninterface IRankedAuction {\\n    function bid(uint256 auctionId, address onBehalfOf, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/misc/WETHGatewayBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {WETHBase} from './WETHBase.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title WETHGatewayBase contract\\n *\\n * @author Aito\\n * @notice Simple WETH gateway contract with basic functionality, must be inherited.\\n */\\ncontract WETHGatewayBase is Ownable, WETHBase {\\n\\n    /**\\n     * @notice Constructor sets the immutable WETH address.\\n     *\\n     * @param weth The WETH address.\\n     */\\n    constructor(address weth) WETHBase(weth) {}\\n\\n    /**\\n     * @dev Admin function authorizes an address through WETH approval.\\n     *\\n     * @param toAuthorize The address to approve with WETH.\\n     */\\n    function authorize(address toAuthorize) external onlyOwner {\\n        WETH.approve(toAuthorize, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\\n     * direct transfers to the contract address.\\n     *\\n     * @param token token to transfer\\n     * @param to recipient of the transfer\\n     * @param amount amount to send\\n     */\\n    function emergencyTokenTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner {\\n        IERC20(token).transfer(to, amount);\\n    }\\n\\n    /**\\n     * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\\n     * due selfdestructs or transfer ether to pre-computated contract address before deployment.\\n     *\\n     * @param to recipient of the transfer\\n     * @param amount amount to send\\n     */\\n    function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\\n        _safeTransferETH(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/WETHBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {IWETH} from '../interfaces/IWETH.sol';\\n\\ncontract WETHBase {\\n\\n    IWETH public immutable WETH;\\n\\n    /**\\n     * @notice Constructor sets the immutable WETH address.\\n     */\\n    constructor(address weth) {\\n        WETH = IWETH(weth);\\n    }\\n\\n    /**\\n    * @dev transfer ETH to an address, revert if it fails.\\n    * @param to recipient of the transfer\\n    * @param value the amount to send\\n    */\\n    function _safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'ETH_TRANSFER_FAILED');\\n    }    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\ninterface IWETH {\\n\\n  function balanceOf(address guy) external returns (uint256);\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n\\n  function approve(address guy, uint256 wad) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 wad\\n  ) external returns (bool);\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "Aave", "timeStamp": "1621810816", "hash": "0x691c28346c4fef4cdb8142b398b0eb8cfb297f3a9b5588799fbbf61dd1dc4634", "contractAddress": "0x47b24fdf2f8ec7b72ac879b124f90f3fc53b51ca", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/misc/RankedAuctionWETHGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {IRankedAuction} from '../interfaces/IRankedAuction.sol';\\nimport {WETHGatewayBase} from './WETHGatewayBase.sol';\\n\\n/**\\n * @title RankedAuctionWETHGateway contract\\n *\\n * @author Aito\\n * @notice Simple gateway to allow bidding in Aito ranked auctions denominated in WETH using ETH.\\n */\\ncontract RankedAuctionWETHGateway is WETHGatewayBase {\\n\\n    constructor(address weth) WETHGatewayBase(weth){}\\n\\n    /**\\n     * @notice Bids using the caller's ETH onBehalfOf the given address.\\n     *\\n     * @param auction The auction address to query an auction to bid on.\\n     * @param auctionId The ranked auction ID to bid on.\\n     * @param onBehalfOf The address to bid on behalf of.\\n     * @param amount The amount to bid.\\n     */\\n    function bidWithEth(\\n        address auction,\\n        uint256 auctionId,\\n        address onBehalfOf,\\n        uint256 amount\\n    ) external payable {\\n        uint256 WETHBefore = WETH.balanceOf(address(this));\\n        WETH.deposit{value: msg.value}();\\n        IRankedAuction(auction).bid(auctionId, onBehalfOf, amount);\\n        uint256 WETHAfter = WETH.balanceOf(address(this));\\n        if (WETHAfter > WETHBefore) {\\n            uint256 diff = WETHAfter - WETHBefore;\\n            WETH.withdraw(diff);\\n            _safeTransferETH(msg.sender, diff);\\n        }\\n        require(WETH.balanceOf(address(this)) == WETHBefore, \\\"RankedAuctionWETHGateway: Invalid WETH After\\\");\\n    }\\n\\n    receive() external payable {\\n        require(msg.sender == address(WETH), \\\"RankedAuctionWETHGateway: Not WETH address\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRankedAuction.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\ninterface IRankedAuction {\\n    function bid(uint256 auctionId, address onBehalfOf, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/misc/WETHGatewayBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {WETHBase} from './WETHBase.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title WETHGatewayBase contract\\n *\\n * @author Aito\\n * @notice Simple WETH gateway contract with basic functionality, must be inherited.\\n */\\ncontract WETHGatewayBase is Ownable, WETHBase {\\n\\n    /**\\n     * @notice Constructor sets the immutable WETH address.\\n     *\\n     * @param weth The WETH address.\\n     */\\n    constructor(address weth) WETHBase(weth) {}\\n\\n    /**\\n     * @dev Admin function authorizes an address through WETH approval.\\n     *\\n     * @param toAuthorize The address to approve with WETH.\\n     */\\n    function authorize(address toAuthorize) external onlyOwner {\\n        WETH.approve(toAuthorize, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\\n     * direct transfers to the contract address.\\n     *\\n     * @param token token to transfer\\n     * @param to recipient of the transfer\\n     * @param amount amount to send\\n     */\\n    function emergencyTokenTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner {\\n        IERC20(token).transfer(to, amount);\\n    }\\n\\n    /**\\n     * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\\n     * due selfdestructs or transfer ether to pre-computated contract address before deployment.\\n     *\\n     * @param to recipient of the transfer\\n     * @param amount amount to send\\n     */\\n    function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\\n        _safeTransferETH(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/WETHBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {IWETH} from '../interfaces/IWETH.sol';\\n\\ncontract WETHBase {\\n\\n    IWETH public immutable WETH;\\n\\n    /**\\n     * @notice Constructor sets the immutable WETH address.\\n     */\\n    constructor(address weth) {\\n        WETH = IWETH(weth);\\n    }\\n\\n    /**\\n    * @dev transfer ETH to an address, revert if it fails.\\n    * @param to recipient of the transfer\\n    * @param value the amount to send\\n    */\\n    function _safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'ETH_TRANSFER_FAILED');\\n    }    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\ninterface IWETH {\\n\\n  function balanceOf(address guy) external returns (uint256);\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n\\n  function approve(address guy, uint256 wad) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 wad\\n  ) external returns (bool);\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "Aave", "timeStamp": "1621646943", "hash": "0x7eb66d10349556e60c37c45dd9de292295fd359462d48f10def1be3fc6c6f2bd", "contractAddress": "0x47b24fdf2f8ec7b72ac879b124f90f3fc53b51ca", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/misc/RankedAuctionWETHGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {IRankedAuction} from '../interfaces/IRankedAuction.sol';\\nimport {WETHGatewayBase} from './WETHGatewayBase.sol';\\n\\n/**\\n * @title RankedAuctionWETHGateway contract\\n *\\n * @author Aito\\n * @notice Simple gateway to allow bidding in Aito ranked auctions denominated in WETH using ETH.\\n */\\ncontract RankedAuctionWETHGateway is WETHGatewayBase {\\n\\n    constructor(address weth) WETHGatewayBase(weth){}\\n\\n    /**\\n     * @notice Bids using the caller's ETH onBehalfOf the given address.\\n     *\\n     * @param auction The auction address to query an auction to bid on.\\n     * @param auctionId The ranked auction ID to bid on.\\n     * @param onBehalfOf The address to bid on behalf of.\\n     * @param amount The amount to bid.\\n     */\\n    function bidWithEth(\\n        address auction,\\n        uint256 auctionId,\\n        address onBehalfOf,\\n        uint256 amount\\n    ) external payable {\\n        uint256 WETHBefore = WETH.balanceOf(address(this));\\n        WETH.deposit{value: msg.value}();\\n        IRankedAuction(auction).bid(auctionId, onBehalfOf, amount);\\n        uint256 WETHAfter = WETH.balanceOf(address(this));\\n        if (WETHAfter > WETHBefore) {\\n            uint256 diff = WETHAfter - WETHBefore;\\n            WETH.withdraw(diff);\\n            _safeTransferETH(msg.sender, diff);\\n        }\\n        require(WETH.balanceOf(address(this)) == WETHBefore, \\\"RankedAuctionWETHGateway: Invalid WETH After\\\");\\n    }\\n\\n    receive() external payable {\\n        require(msg.sender == address(WETH), \\\"RankedAuctionWETHGateway: Not WETH address\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRankedAuction.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\ninterface IRankedAuction {\\n    function bid(uint256 auctionId, address onBehalfOf, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/misc/WETHGatewayBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {WETHBase} from './WETHBase.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title WETHGatewayBase contract\\n *\\n * @author Aito\\n * @notice Simple WETH gateway contract with basic functionality, must be inherited.\\n */\\ncontract WETHGatewayBase is Ownable, WETHBase {\\n\\n    /**\\n     * @notice Constructor sets the immutable WETH address.\\n     *\\n     * @param weth The WETH address.\\n     */\\n    constructor(address weth) WETHBase(weth) {}\\n\\n    /**\\n     * @dev Admin function authorizes an address through WETH approval.\\n     *\\n     * @param toAuthorize The address to approve with WETH.\\n     */\\n    function authorize(address toAuthorize) external onlyOwner {\\n        WETH.approve(toAuthorize, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\\n     * direct transfers to the contract address.\\n     *\\n     * @param token token to transfer\\n     * @param to recipient of the transfer\\n     * @param amount amount to send\\n     */\\n    function emergencyTokenTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner {\\n        IERC20(token).transfer(to, amount);\\n    }\\n\\n    /**\\n     * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\\n     * due selfdestructs or transfer ether to pre-computated contract address before deployment.\\n     *\\n     * @param to recipient of the transfer\\n     * @param amount amount to send\\n     */\\n    function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\\n        _safeTransferETH(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/WETHBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\nimport {IWETH} from '../interfaces/IWETH.sol';\\n\\ncontract WETHBase {\\n\\n    IWETH public immutable WETH;\\n\\n    /**\\n     * @notice Constructor sets the immutable WETH address.\\n     */\\n    constructor(address weth) {\\n        WETH = IWETH(weth);\\n    }\\n\\n    /**\\n    * @dev transfer ETH to an address, revert if it fails.\\n    * @param to recipient of the transfer\\n    * @param value the amount to send\\n    */\\n    function _safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'ETH_TRANSFER_FAILED');\\n    }    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\n\\ninterface IWETH {\\n\\n  function balanceOf(address guy) external returns (uint256);\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n\\n  function approve(address guy, uint256 wad) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 wad\\n  ) external returns (bool);\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "Aave", "timeStamp": "1621539969", "hash": "0x31ccee4f6ae7551ea318669ecfa4a3d351e85dbbf579358557094de309776dd9", "contractAddress": "0x76e2cfc1f5fa8f6a5b3fc4c8f4788f0116861f9b", "SourceCode": "pragma solidity ^0.5.3;\r\n\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(Proxy proxy, address _mastercopy, bytes calldata initializer, uint256 saltNonce) external;\r\n}\r\n\r\n\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract Proxy {\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal masterCopy;\r\n\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy)\r\n        public\r\n    {\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, masterCopy)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { revert(0, returndatasize()) }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract ProxyFactory {\r\n\r\n    event ProxyCreation(Proxy proxy);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param masterCopy Address of master copy.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address masterCopy, bytes memory data)\r\n        public\r\n        returns (Proxy proxy)\r\n    {\r\n        proxy = new Proxy(masterCopy);\r\n        if (data.length > 0)\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n            }\r\n        emit ProxyCreation(proxy);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(Proxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(Proxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _mastercopy Address of master copy.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\r\n        internal\r\n        returns (Proxy proxy)\r\n    {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint256(_mastercopy));\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _mastercopy Address of master copy.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\r\n        public\r\n        returns (Proxy proxy)\r\n    {\r\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas, proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) { revert(0,0) }\r\n            }\r\n        emit ProxyCreation(proxy);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _mastercopy Address of master copy.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(address _mastercopy, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback)\r\n        public\r\n        returns (Proxy proxy)\r\n    {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_mastercopy, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0))\r\n            callback.proxyCreated(proxy, _mastercopy, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _mastercopy Address of master copy.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(address _mastercopy, bytes calldata initializer, uint256 saltNonce)\r\n        external\r\n        returns (Proxy proxy)\r\n    {\r\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n\r\n}"}, {"protocol": "Aave", "timeStamp": "1613250979", "hash": "0x3c285bdef1fed92a7b3dcc71a6e82f967c935f225ecac60bd4a76746d282c2c1", "contractAddress": "0xec568fffba86c094cf06b22134b23074dfe2252c", "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"}, {"protocol": "Aave", "timeStamp": "1612307058", "hash": "0x82fc10adae4c157dd06e54ec49e01cdf711a0f4e7d55f33bfe651388a2d7bd0e", "contractAddress": "0x7d2768de32b0b80b7a3454c06bdac94a69ddc7a9", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './BaseImmutableAdminUpgradeabilityProxy.sol';\\nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableAdminUpgradeabilityProxy\\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\\n */\\ncontract InitializableImmutableAdminUpgradeabilityProxy is\\n  BaseImmutableAdminUpgradeabilityProxy,\\n  InitializableUpgradeabilityProxy\\n{\\n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {}\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title BaseImmutableAdminUpgradeabilityProxy\\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\\n * helps saving transactions costs\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  address immutable ADMIN;\\n\\n  constructor(address admin) public {\\n    ADMIN = admin;\\n  }\\n\\n  modifier ifAdmin() {\\n    if (msg.sender == ADMIN) {\\n      _;\\n    } else {\\n      _fallback();\\n    }\\n  }\\n\\n  /**\\n   * @return The address of the proxy admin.\\n   */\\n  function admin() external ifAdmin returns (address) {\\n    return ADMIN;\\n  }\\n\\n  /**\\n   * @return The address of the implementation.\\n   */\\n  function implementation() external ifAdmin returns (address) {\\n    return _implementation();\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function upgradeTo(address newImplementation) external ifAdmin {\\n    _upgradeTo(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\\n    external\\n    payable\\n    ifAdmin\\n  {\\n    _upgradeTo(newImplementation);\\n    (bool success, ) = newImplementation.delegatecall(data);\\n    require(success);\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal virtual override {\\n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');\\n    super._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './Proxy.sol';\\nimport '../contracts/Address.sol';\\n\\n/**\\n * @title BaseUpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract BaseUpgradeabilityProxy is Proxy {\\n  /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n  event Upgraded(address indexed implementation);\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n  /**\\n   * @dev Returns the current implementation.\\n   * @return impl Address of the current implementation\\n   */\\n  function _implementation() internal override view returns (address impl) {\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n    //solium-disable-next-line\\n    assembly {\\n      impl := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _upgradeTo(address newImplementation) internal {\\n    _setImplementation(newImplementation);\\n    emit Upgraded(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _setImplementation(address newImplementation) internal {\\n    require(\\n      Address.isContract(newImplementation),\\n      'Cannot set a proxy implementation to a non-contract address'\\n    );\\n\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n    //solium-disable-next-line\\n    assembly {\\n      sstore(slot, newImplementation)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\nabstract contract Proxy {\\n  /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n  fallback() external payable {\\n    _fallback();\\n  }\\n\\n  /**\\n   * @return The Address of the implementation.\\n   */\\n  function _implementation() internal virtual view returns (address);\\n\\n  /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n  function _delegate(address implementation) internal {\\n    //solium-disable-next-line\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize())\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize())\\n\\n      switch result\\n        // delegatecall returns 0 on error.\\n        case 0 {\\n          revert(0, returndatasize())\\n        }\\n        default {\\n          return(0, returndatasize())\\n        }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n  function _willFallback() internal virtual {}\\n\\n  /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n  function _fallback() internal {\\n    _willFallback();\\n    _delegate(_implementation());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableUpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\n * implementation and init data.\\n */\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  /**\\n   * @dev Contract initializer.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  function initialize(address _logic, bytes memory _data) public payable {\\n    require(_implementation() == address(0));\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\\n    _setImplementation(_logic);\\n    if (_data.length > 0) {\\n      (bool success, ) = _logic.delegatecall(_data);\\n      require(success);\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "Aave", "timeStamp": "1612306439", "hash": "0xad602998d0622e97499442a6a64420b2ee20732192a5559efc78b0b74d899cb4", "contractAddress": "0x7d2768de32b0b80b7a3454c06bdac94a69ddc7a9", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './BaseImmutableAdminUpgradeabilityProxy.sol';\\nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableAdminUpgradeabilityProxy\\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\\n */\\ncontract InitializableImmutableAdminUpgradeabilityProxy is\\n  BaseImmutableAdminUpgradeabilityProxy,\\n  InitializableUpgradeabilityProxy\\n{\\n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {}\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title BaseImmutableAdminUpgradeabilityProxy\\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\\n * helps saving transactions costs\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  address immutable ADMIN;\\n\\n  constructor(address admin) public {\\n    ADMIN = admin;\\n  }\\n\\n  modifier ifAdmin() {\\n    if (msg.sender == ADMIN) {\\n      _;\\n    } else {\\n      _fallback();\\n    }\\n  }\\n\\n  /**\\n   * @return The address of the proxy admin.\\n   */\\n  function admin() external ifAdmin returns (address) {\\n    return ADMIN;\\n  }\\n\\n  /**\\n   * @return The address of the implementation.\\n   */\\n  function implementation() external ifAdmin returns (address) {\\n    return _implementation();\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function upgradeTo(address newImplementation) external ifAdmin {\\n    _upgradeTo(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\\n    external\\n    payable\\n    ifAdmin\\n  {\\n    _upgradeTo(newImplementation);\\n    (bool success, ) = newImplementation.delegatecall(data);\\n    require(success);\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal virtual override {\\n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');\\n    super._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './Proxy.sol';\\nimport '../contracts/Address.sol';\\n\\n/**\\n * @title BaseUpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract BaseUpgradeabilityProxy is Proxy {\\n  /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n  event Upgraded(address indexed implementation);\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n  /**\\n   * @dev Returns the current implementation.\\n   * @return impl Address of the current implementation\\n   */\\n  function _implementation() internal override view returns (address impl) {\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n    //solium-disable-next-line\\n    assembly {\\n      impl := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _upgradeTo(address newImplementation) internal {\\n    _setImplementation(newImplementation);\\n    emit Upgraded(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _setImplementation(address newImplementation) internal {\\n    require(\\n      Address.isContract(newImplementation),\\n      'Cannot set a proxy implementation to a non-contract address'\\n    );\\n\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n    //solium-disable-next-line\\n    assembly {\\n      sstore(slot, newImplementation)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\nabstract contract Proxy {\\n  /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n  fallback() external payable {\\n    _fallback();\\n  }\\n\\n  /**\\n   * @return The Address of the implementation.\\n   */\\n  function _implementation() internal virtual view returns (address);\\n\\n  /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n  function _delegate(address implementation) internal {\\n    //solium-disable-next-line\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize())\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize())\\n\\n      switch result\\n        // delegatecall returns 0 on error.\\n        case 0 {\\n          revert(0, returndatasize())\\n        }\\n        default {\\n          return(0, returndatasize())\\n        }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n  function _willFallback() internal virtual {}\\n\\n  /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n  function _fallback() internal {\\n    _willFallback();\\n    _delegate(_implementation());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport './BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableUpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\n * implementation and init data.\\n */\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  /**\\n   * @dev Contract initializer.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  function initialize(address _logic, bytes memory _data) public payable {\\n    require(_implementation() == address(0));\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\\n    _setImplementation(_logic);\\n    if (_data.length > 0) {\\n      (bool success, ) = _logic.delegatecall(_data);\\n      require(success);\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "Aave", "timeStamp": "1612306399", "hash": "0xf1e9552a485ef113d81fcccacc46d98437646cd9a88ffc1768c185f2438e03dd", "contractAddress": "0xba100000625a3754423978a60c9317c58a424e3d", "SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File @openzeppelin/contracts/utils/EnumerableSet.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v3.0.1\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/GSN/Context.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/AccessControl.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using Address for address;\r\n\r\n    struct RoleData {\r\n        EnumerableSet.AddressSet members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping (bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view returns (bool) {\r\n        return _roles[role].members.contains(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of accounts that have `role`. Can be used\r\n     * together with {getRoleMember} to enumerate all bearers of a role.\r\n     */\r\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\r\n        return _roles[role].members.length();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns one of the accounts that have `role`. `index` must be a\r\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n     *\r\n     * Role bearers are not sorted in any particular way, and their ordering may\r\n     * change at any point.\r\n     *\r\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n     * you perform all queries on the same block. See the following\r\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n     * for more information.\r\n     */\r\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\r\n        return _roles[role].members.at(index);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual {\r\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\r\n\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual {\r\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        _roles[role].adminRole = adminRole;\r\n    }\r\n\r\n    function _grantRole(bytes32 role, address account) private {\r\n        if (_roles[role].members.add(account)) {\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    function _revokeRole(bytes32 role, address account) private {\r\n        if (_roles[role].members.remove(account)) {\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/Math.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Arrays.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to array types.\r\n */\r\nlibrary Arrays {\r\n   /**\r\n     * @dev Searches a sorted `array` and returns the first index that contains\r\n     * a value greater or equal to `element`. If no such index exists (i.e. all\r\n     * values in the array are strictly less than `element`), the array length is\r\n     * returned. Time complexity O(log n).\r\n     *\r\n     * `array` is expected to be sorted in ascending order, and to contain no\r\n     * repeated elements.\r\n     */\r\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\r\n        if (array.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 low = 0;\r\n        uint256 high = array.length;\r\n\r\n        while (low < high) {\r\n            uint256 mid = Math.average(low, high);\r\n\r\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\r\n            // because Math.average rounds down (it does integer division with truncation).\r\n            if (array[mid] > element) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\r\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\r\n        if (low > 0 && array[low - 1] == element) {\r\n            return low - 1;\r\n        } else {\r\n            return low;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Counters.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20MinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol@v3.0.1\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\r\n * total supply at the time are recorded for later access.\r\n *\r\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\r\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\r\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\r\n * used to create an efficient ERC20 forking mechanism.\r\n *\r\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\r\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\r\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\r\n * and the account address.\r\n *\r\n * ==== Gas Costs\r\n *\r\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\r\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\r\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\r\n *\r\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\r\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\r\n * transfers will have normal cost until the next snapshot, and so on.\r\n */\r\nabstract contract ERC20Snapshot is ERC20 {\r\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\r\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\r\n\r\n    using SafeMath for uint256;\r\n    using Arrays for uint256[];\r\n    using Counters for Counters.Counter;\r\n\r\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\r\n    // Snapshot struct, but that would impede usage of functions that work on an array.\r\n    struct Snapshots {\r\n        uint256[] ids;\r\n        uint256[] values;\r\n    }\r\n\r\n    mapping (address => Snapshots) private _accountBalanceSnapshots;\r\n    Snapshots private _totalSupplySnapshots;\r\n\r\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\r\n    Counters.Counter private _currentSnapshotId;\r\n\r\n    /**\r\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\r\n     */\r\n    event Snapshot(uint256 id);\r\n\r\n    /**\r\n     * @dev Creates a new snapshot and returns its snapshot id.\r\n     *\r\n     * Emits a {Snapshot} event that contains the same id.\r\n     *\r\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\r\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\r\n     * you must consider that it can potentially be used by attackers in two ways.\r\n     *\r\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\r\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\r\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\r\n     * section above.\r\n     *\r\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\r\n     * ====\r\n     */\r\n    function _snapshot() internal virtual returns (uint256) {\r\n        _currentSnapshotId.increment();\r\n\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        emit Snapshot(currentId);\r\n        return currentId;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\r\n     */\r\n    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\r\n\r\n        return snapshotted ? value : balanceOf(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\r\n     */\r\n    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\r\n\r\n        return snapshotted ? value : totalSupply();\r\n    }\r\n\r\n    // _transfer, _mint and _burn are the only functions where the balances are modified, so it is there that the\r\n    // snapshots are updated. Note that the update happens _before_ the balance change, with the pre-modified value.\r\n    // The same is true for the total supply and _mint and _burn.\r\n    function _transfer(address from, address to, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(from);\r\n        _updateAccountSnapshot(to);\r\n\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._mint(account, value);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._burn(account, value);\r\n    }\r\n\r\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\r\n        private view returns (bool, uint256)\r\n    {\r\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(snapshotId <= _currentSnapshotId.current(), \"ERC20Snapshot: nonexistent id\");\r\n\r\n        // When a valid snapshot is queried, there are three possibilities:\r\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\r\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\r\n        //  to this id is the current one.\r\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\r\n        //  requested id, and its value is the one to return.\r\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\r\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\r\n        //  larger than the requested one.\r\n        //\r\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\r\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\r\n        // exactly this.\r\n\r\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\r\n\r\n        if (index == snapshots.ids.length) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, snapshots.values[index]);\r\n        }\r\n    }\r\n\r\n    function _updateAccountSnapshot(address account) private {\r\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\r\n    }\r\n\r\n    function _updateTotalSupplySnapshot() private {\r\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\r\n    }\r\n\r\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\r\n            snapshots.ids.push(currentId);\r\n            snapshots.values.push(currentValue);\r\n        }\r\n    }\r\n\r\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\r\n        if (ids.length == 0) {\r\n            return 0;\r\n        } else {\r\n            return ids[ids.length - 1];\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/BalancerGovernanceToken.sol\r\n\r\npragma solidity =0.6.8;\r\n\r\n\r\n\r\ncontract BalancerGovernanceToken is AccessControl, ERC20Snapshot {\r\n\r\n    string  public constant version  = \"1\";\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n    bytes32 public constant SNAPSHOT_ROLE = keccak256(\"SNAPSHOT_ROLE\");\r\n\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public immutable PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public nonces;\r\n\r\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        _setupRole(MINTER_ROLE, _msgSender());\r\n        _setupRole(SNAPSHOT_ROLE, _msgSender());\r\n\r\n        uint256 chainId = _chainID();\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(version)),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _chainID() private pure returns (uint256) {\r\n        uint256 chainID;\r\n        assembly {\r\n            chainID := chainid()\r\n        }\r\n        return chainID;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(block.timestamp <= deadline, \"ERR_EXPIRED_SIG\");\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                uint16(0x1901),\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        require(owner == _recover(digest, v, r, s), \"ERR_INVALID_SIG\");\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    function _recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) private pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public virtual {\r\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERR_MINTER_ROLE\");\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\r\n\r\n        _approve(account, _msgSender(), decreasedAllowance);\r\n        _burn(account, amount);\r\n    }\r\n\r\n    function snapshot() public virtual {\r\n        require(hasRole(SNAPSHOT_ROLE, _msgSender()), \"ERR_SNAPSHOT_ROLE\");\r\n        _snapshot();\r\n    }\r\n\r\n}"}, {"protocol": "Aave", "timeStamp": "1612306303", "hash": "0x1cebde96f9a31ffe66f7b3f3c888950d21e34ad8bfdec53618cc61ff57bda81e", "contractAddress": "0x7a250d5630b4cf539739df2c5dacb4c659f2488d", "SourceCode": "pragma solidity =0.6.6;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract UniswapV2Router02 is IUniswapV2Router02 {\r\n    using SafeMath for uint;\r\n\r\n    address public immutable override factory;\r\n    address public immutable override WETH;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) public {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal virtual returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IUniswapV2Pair(pair).mint(to);\r\n    }\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        assert(IWETH(WETH).transfer(pair, amountETH));\r\n        liquidity = IUniswapV2Pair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\r\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\r\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountToken, uint amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n        );\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            { // scope to avoid stack too deep errors\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        uint amountIn = msg.value;\r\n        IWETH(WETH).deposit{value: amountIn}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\r\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountOut)\r\n    {\r\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountIn)\r\n    {\r\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint amountIn, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint amountOut, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n    }\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}"}, {"protocol": "Aave", "timeStamp": "1612305941", "hash": "0xd0a5c69bbd50d840c760c5c1afd9b0de0b8892a5a018d799a637a858bb8de49f", "contractAddress": "0xec568fffba86c094cf06b22134b23074dfe2252c", "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"}][{"protocol": "bdglabs.eth", "timeStamp": "1687517351", "hash": "0xd641637b812240498a148e46b5e7f2cb27f3d0e6becdca1f64cd26e7887c3e38", "contractAddress": "0xb812d0944f8f581dfaa3a93dda0d22ecef51a9cf", "SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1687162643", "hash": "0x240d4c088cf4803e97aa1951056e86eee8d309ba51f3413a74e00173a145108d", "contractAddress": "0xec568fffba86c094cf06b22134b23074dfe2252c", "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1686904991", "hash": "0x34163fbd47cc90149cdf234b79144caa2a566916efff5b9990aec787c4fbc0f1", "contractAddress": "0xb812d0944f8f581dfaa3a93dda0d22ecef51a9cf", "SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1686904799", "hash": "0x988b2819155ab83d9066e90cd457faf065555667612b8deb5299301312f87fa6", "contractAddress": "0xb812d0944f8f581dfaa3a93dda0d22ecef51a9cf", "SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1686653663", "hash": "0xd43545370d0ee7696393781b8907aaddb521cc1efa6f2b5e67ac69ded36f4732", "contractAddress": "0xb812d0944f8f581dfaa3a93dda0d22ecef51a9cf", "SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1686116087", "hash": "0xb66351d2a29e2b2b4434ddb4d5ba39439d88b24b9d29d91a6578f5f84660ca63", "contractAddress": "0xec568fffba86c094cf06b22134b23074dfe2252c", "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1685701067", "hash": "0x768cc0a3d3dafa47e8e5b505ea964b9a21b1433aedd84eb94c6b11f21ad63f3d", "contractAddress": "0xb812d0944f8f581dfaa3a93dda0d22ecef51a9cf", "SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1685389439", "hash": "0xa8eeb916a20acd366a03cc599fda66c89b31b9444bcf39dc722448a64c2c5853", "contractAddress": "0xec568fffba86c094cf06b22134b23074dfe2252c", "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1684865015", "hash": "0x7edd370e03996a283e76df423b0562aeb0a18f5a3025df6024be9562b8d2959e", "contractAddress": "0xec568fffba86c094cf06b22134b23074dfe2252c", "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"}, {"protocol": "bdglabs.eth", "timeStamp": "1684846451", "hash": "0xd961bb5d504215c89535821c223e84d3e99f5405f2b6178dcfc16c3f71d492fe", "contractAddress": "0x514910771af9ca656af840dff83e8264ecf986ca", "SourceCode": "pragma solidity ^0.4.16;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC677 is ERC20 {\r\n  function transferAndCall(address to, uint value, bytes data) returns (bool success);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\ncontract ERC677Receiver {\r\n  function onTokenTransfer(address _sender, uint _value, bytes _data);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n  \r\n    /*\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until \r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) \r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) \r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC677Token is ERC677 {\r\n\r\n  /**\r\n  * @dev transfer token to a contract address with additional data if the recipient is a contact.\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  * @param _data The extra data to be passed to the receiving contract.\r\n  */\r\n  function transferAndCall(address _to, uint _value, bytes _data)\r\n    public\r\n    returns (bool success)\r\n  {\r\n    super.transfer(_to, _value);\r\n    Transfer(msg.sender, _to, _value, _data);\r\n    if (isContract(_to)) {\r\n      contractFallback(_to, _value, _data);\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\n  // PRIVATE\r\n\r\n  function contractFallback(address _to, uint _value, bytes _data)\r\n    private\r\n  {\r\n    ERC677Receiver receiver = ERC677Receiver(_to);\r\n    receiver.onTokenTransfer(msg.sender, _value, _data);\r\n  }\r\n\r\n  function isContract(address _addr)\r\n    private\r\n    returns (bool hasCode)\r\n  {\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n\r\n}\r\n\r\ncontract LinkToken is StandardToken, ERC677Token {\r\n\r\n  uint public constant totalSupply = 10**27;\r\n  string public constant name = 'ChainLink Token';\r\n  uint8 public constant decimals = 18;\r\n  string public constant symbol = 'LINK';\r\n\r\n  function LinkToken()\r\n    public\r\n  {\r\n    balances[msg.sender] = totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token to a specified address with additional data if the recipient is a contract.\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  * @param _data The extra data to be passed to the receiving contract.\r\n  */\r\n  function transferAndCall(address _to, uint _value, bytes _data)\r\n    public\r\n    validRecipient(_to)\r\n    returns (bool success)\r\n  {\r\n    return super.transferAndCall(_to, _value, _data);\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token to a specified address.\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint _value)\r\n    public\r\n    validRecipient(_to)\r\n    returns (bool success)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value)\r\n    public\r\n    validRecipient(_spender)\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender,  _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    validRecipient(_to)\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n\r\n  // MODIFIERS\r\n\r\n  modifier validRecipient(address _recipient) {\r\n    require(_recipient != address(0) && _recipient != address(this));\r\n    _;\r\n  }\r\n\r\n}"}][{"protocol": "Uniswap", "timeStamp": "1671816083", "hash": "0x69c44d8767a37feabc35be70de595670323ac8e750a7c7fce2baac0157d3dffd", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1671815579", "hash": "0xe4125775a0d809a96d0003add574684ef711088538d87c883de75587bd5dc85b", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1669618343", "hash": "0xfe79f3865dc9a933c8b88c90970672ddf4a9e4879e302ce864988ca938636321", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1663697459", "hash": "0x635fd1c5775dd26bdaa91224f49a548cd277cdf276e1ffc3374ee6e5fb33048c", "contractAddress": "0xfc43582532e90fa8726fe9cdb5fad48f4e487d27", "SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}"}, {"protocol": "Uniswap", "timeStamp": "1663697231", "hash": "0xe610f592f7a30039c7aa85de9c8cf83fe69535db3fca6adff23fc66cd2054287", "contractAddress": "0xb753548f6e010e7e680ba186f9ca1bdab2e90cf2", "SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don\\u0027t know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"},\"ProxyAdmin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./TransparentUpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"},\"TransparentUpgradeableProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it\\u0027s best if it\\u0027s a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n     */\\n    constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _admin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        require(newAdmin != address(0), \\\"TransparentUpgradeableProxy: new admin is the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n        Address.functionDelegateCall(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address adm) {\\n        bytes32 slot = _ADMIN_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        bytes32 slot = _ADMIN_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _admin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"},\"UpgradeableProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\\u0027t conflict with the storage layout of the\\n * implementation behind the proxy.\\n *\\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it\\u0027s used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if(_data.length \\u003e 0) {\\n            Address.functionDelegateCall(_logic, _data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal virtual {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableProxy: new implementation is not a contract\\\");\\n\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"}}"}, {"protocol": "Uniswap", "timeStamp": "1654391981", "hash": "0xd71ec38bd59269a14a22add93832770fdd1acc0c4f96eaf0c318753a798e1cb3", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1653935360", "hash": "0xa543d2b1e7396e2e9c15e537430d781fbc85791302ba54be09f2f8b73e3c4d34", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1649852351", "hash": "0xaf9fdcd33eba1c4412aab80d896ca9ef19a1ff2e555508c5573d56068ba79437", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1649821685", "hash": "0x292b0d0e92fc394f1151daad6773296a9380560457e3044e543f3acf9aaaa917", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1648872375", "hash": "0xdbd1905fe70c50f935b2895049c621097b2f3115b3cd4186688612f0adeac7da", "contractAddress": "0x6c9fc64a53c1b71fb3f9af64d1ae3a4931a5f4e9", "SourceCode": ""}][{"protocol": "Uniswap", "timeStamp": "1668651767", "hash": "0x3c04237fea922287adb0b43bf5562481aaefc6d502e7bebf87e2eb0eeaff512d", "contractAddress": "0x2784a755690453035f32ac5e28c52524d127afe2", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bridge/ETHHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {BridgeRouter} from \\\"./BridgeRouter.sol\\\";\\nimport {IWeth} from \\\"../../interfaces/bridge/IWeth.sol\\\";\\n// ============ External Imports ============\\nimport {TypeCasts} from \\\"@celo-org/optics-sol/contracts/XAppConnectionManager.sol\\\";\\n\\ncontract ETHHelper {\\n    // ============ Immutables ============\\n\\n    // wrapped Ether contract\\n    IWeth public immutable weth;\\n    // bridge router contract\\n    BridgeRouter public immutable bridge;\\n\\n    // ============ Constructor ============\\n\\n    constructor(address _weth, address _bridge) {\\n        weth = IWeth(_weth);\\n        bridge = BridgeRouter(_bridge);\\n        IWeth(_weth).approve(_bridge, uint256(-1));\\n    }\\n\\n    // ============ External Functions ============\\n\\n    /**\\n     * @notice Sends ETH over the Optics Bridge. Sends to a full-width Optics\\n     * identifer on the other side.\\n     * @dev As with all bridges, improper use may result in loss of funds.\\n     * @param _domain The domain to send funds to.\\n     * @param _to The 32-byte identifier of the recipient\\n     */\\n    function sendTo(uint32 _domain, bytes32 _to) public payable {\\n        weth.deposit{value: msg.value}();\\n        bridge.send(address(weth), msg.value, _domain, _to);\\n    }\\n\\n    /**\\n     * @notice Sends ETH over the Optics Bridge. Sends to the same address on\\n     * the other side.\\n     * @dev WARNING: This function should only be used when sending TO an\\n     * EVM-like domain. As with all bridges, improper use may result in loss of\\n     * funds.\\n     * @param _domain The domain to send funds to\\n     */\\n    function send(uint32 _domain) external payable {\\n        sendTo(_domain, TypeCasts.addressToBytes32(msg.sender));\\n    }\\n\\n    /**\\n     * @notice Sends ETH over the Optics Bridge. Sends to a specified EVM\\n     * address on the other side.\\n     * @dev This function should only be used when sending TO an EVM-like\\n     * domain. As with all bridges, improper use may result in loss of funds\\n     * @param _domain The domain to send funds to.\\n     * @param _to The EVM address of the recipient\\n     */\\n    function sendToEVMLike(uint32 _domain, address _to) external payable {\\n        sendTo(_domain, TypeCasts.addressToBytes32(_to));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/BridgeRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {TokenRegistry} from \\\"./TokenRegistry.sol\\\";\\nimport {Router} from \\\"../Router.sol\\\";\\nimport {XAppConnectionClient} from \\\"../XAppConnectionClient.sol\\\";\\nimport {IBridgeToken} from \\\"../../interfaces/bridge/IBridgeToken.sol\\\";\\nimport {BridgeMessage} from \\\"./BridgeMessage.sol\\\";\\n// ============ External Imports ============\\nimport {Home} from \\\"@celo-org/optics-sol/contracts/Home.sol\\\";\\nimport {Version0} from \\\"@celo-org/optics-sol/contracts/Version0.sol\\\";\\nimport {TypeCasts} from \\\"@celo-org/optics-sol/contracts/XAppConnectionManager.sol\\\";\\nimport {TypedMemView} from \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n/**\\n * @title BridgeRouter\\n */\\ncontract BridgeRouter is Version0, Router, TokenRegistry {\\n    // ============ Libraries ============\\n\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n    using BridgeMessage for bytes29;\\n    using SafeERC20 for IERC20;\\n\\n    // ============ Constants ============\\n\\n    // 5 bps (0.05%) hardcoded fast liquidity fee. Can be changed by contract upgrade\\n    uint256 public constant PRE_FILL_FEE_NUMERATOR = 9995;\\n    uint256 public constant PRE_FILL_FEE_DENOMINATOR = 10000;\\n\\n    // ============ Public Storage ============\\n\\n    // token transfer prefill ID => LP that pre-filled message to provide fast liquidity\\n    mapping(bytes32 => address) public liquidityProvider;\\n\\n    // ============ Upgrade Gap ============\\n\\n    // gap for upgrade safety\\n    uint256[49] private __GAP;\\n\\n    // ======== Events =========\\n\\n    /**\\n     * @notice emitted when tokens are sent from this domain to another domain\\n     * @param token the address of the token contract\\n     * @param from the address sending tokens\\n     * @param toDomain the domain of the chain the tokens are being sent to\\n     * @param toId the bytes32 address of the recipient of the tokens\\n     * @param amount the amount of tokens sent\\n     */\\n    event Send(\\n        address indexed token,\\n        address indexed from,\\n        uint32 indexed toDomain,\\n        bytes32 toId,\\n        uint256 amount\\n    );\\n\\n    // ======== Initializer ========\\n\\n    function initialize(address _tokenBeacon, address _xAppConnectionManager)\\n        public\\n        initializer\\n    {\\n        __TokenRegistry_initialize(_tokenBeacon);\\n        __XAppConnectionClient_initialize(_xAppConnectionManager);\\n    }\\n\\n    // ======== External: Handle =========\\n\\n    /**\\n     * @notice Handles an incoming message\\n     * @param _origin The origin domain\\n     * @param _sender The sender address\\n     * @param _message The message\\n     */\\n    function handle(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes memory _message\\n    ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\\n        // parse tokenId and action from message\\n        bytes29 _msg = _message.ref(0).mustBeMessage();\\n        bytes29 _tokenId = _msg.tokenId();\\n        bytes29 _action = _msg.action();\\n        // handle message based on the intended action\\n        if (_action.isTransfer()) {\\n            _handleTransfer(_tokenId, _action);\\n        } else if (_action.isDetails()) {\\n            _handleDetails(_tokenId, _action);\\n        } else if (_action.isRequestDetails()) {\\n            _handleRequestDetails(_origin, _sender, _tokenId);\\n        } else {\\n            require(false, \\\"!valid action\\\");\\n        }\\n    }\\n\\n    // ======== External: Request Token Details =========\\n\\n    /**\\n     * @notice Request updated token metadata from another chain\\n     * @dev This is only owner to prevent abuse and spam. Requesting details\\n     *  should be done automatically on token instantiation\\n     * @param _domain The domain where that token is native\\n     * @param _id The token id on that domain\\n     */\\n    function requestDetails(uint32 _domain, bytes32 _id) external onlyOwner {\\n        bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\\n        _requestDetails(_tokenId);\\n    }\\n\\n    // ======== External: Send Token =========\\n\\n    /**\\n     * @notice Send tokens to a recipient on a remote chain\\n     * @param _token The token address\\n     * @param _amount The token amount\\n     * @param _destination The destination domain\\n     * @param _recipient The recipient address\\n     */\\n    function send(\\n        address _token,\\n        uint256 _amount,\\n        uint32 _destination,\\n        bytes32 _recipient\\n    ) external {\\n        require(_amount > 0, \\\"!amnt\\\");\\n        require(_recipient != bytes32(0), \\\"!recip\\\");\\n        // get remote BridgeRouter address; revert if not found\\n        bytes32 _remote = _mustHaveRemote(_destination);\\n        // remove tokens from circulation on this chain\\n        IERC20 _bridgeToken = IERC20(_token);\\n        if (_isLocalOrigin(_bridgeToken)) {\\n            // if the token originates on this chain, hold the tokens in escrow\\n            // in the Router\\n            _bridgeToken.safeTransferFrom(msg.sender, address(this), _amount);\\n        } else {\\n            // if the token originates on a remote chain, burn the\\n            // representation tokens on this chain\\n            _downcast(_bridgeToken).burn(msg.sender, _amount);\\n        }\\n        // format Transfer Tokens action\\n        bytes29 _action = BridgeMessage.formatTransfer(_recipient, _amount);\\n        // send message to remote chain via Optics\\n        Home(xAppConnectionManager.home()).dispatch(\\n            _destination,\\n            _remote,\\n            BridgeMessage.formatMessage(_formatTokenId(_token), _action)\\n        );\\n        // emit Send event to record token sender\\n        emit Send(\\n            address(_bridgeToken),\\n            msg.sender,\\n            _destination,\\n            _recipient,\\n            _amount\\n        );\\n    }\\n\\n    // ======== External: Fast Liquidity =========\\n\\n    /**\\n     * @notice Allows a liquidity provider to give an\\n     * end user fast liquidity by pre-filling an\\n     * incoming transfer message.\\n     * Transfers tokens from the liquidity provider to the end recipient, minus the LP fee;\\n     * Records the liquidity provider, who receives\\n     * the full token amount when the transfer message is handled.\\n     * @dev fast liquidity can only be provided for ONE token transfer\\n     * with the same (recipient, amount) at a time.\\n     * in the case that multiple token transfers with the same (recipient, amount)\\n     * @param _message The incoming transfer message to pre-fill\\n     */\\n    function preFill(bytes calldata _message) external {\\n        // parse tokenId and action from message\\n        bytes29 _msg = _message.ref(0).mustBeMessage();\\n        bytes29 _tokenId = _msg.tokenId().mustBeTokenId();\\n        bytes29 _action = _msg.action().mustBeTransfer();\\n        // calculate prefill ID\\n        bytes32 _id = _preFillId(_tokenId, _action);\\n        // require that transfer has not already been pre-filled\\n        require(liquidityProvider[_id] == address(0), \\\"!unfilled\\\");\\n        // record liquidity provider\\n        liquidityProvider[_id] = msg.sender;\\n        // transfer tokens from liquidity provider to token recipient\\n        IERC20 _token = _mustHaveToken(_tokenId);\\n        _token.safeTransferFrom(\\n            msg.sender,\\n            _action.evmRecipient(),\\n            _applyPreFillFee(_action.amnt())\\n        );\\n    }\\n\\n    // ======== External: Custom Tokens =========\\n\\n    /**\\n     * @notice Enroll a custom token. This allows projects to work with\\n     * governance to specify a custom representation.\\n     * @dev This is done by inserting the custom representation into the token\\n     * lookup tables. It is permissioned to the owner (governance) and can\\n     * potentially break token representations. It must be used with extreme\\n     * caution.\\n     * After the token is inserted, new mint instructions will be sent to the\\n     * custom token. The default representation (and old custom representations)\\n     * may still be burnt. Until all users have explicitly called migrate, both\\n     * representations will continue to exist.\\n     * The custom representation MUST be trusted, and MUST allow the router to\\n     * both mint AND burn tokens at will.\\n     * @param _id the canonical ID of the Token to enroll, as a byte vector\\n     * @param _custom the address of the custom implementation to use.\\n     */\\n    function enrollCustom(\\n        uint32 _domain,\\n        bytes32 _id,\\n        address _custom\\n    ) external onlyOwner {\\n        // Sanity check. Ensures that human error doesn't cause an\\n        // unpermissioned contract to be enrolled.\\n        IBridgeToken(_custom).mint(address(this), 1);\\n        IBridgeToken(_custom).burn(address(this), 1);\\n        // update mappings with custom token\\n        bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\\n        representationToCanonical[_custom].domain = _tokenId.domain();\\n        representationToCanonical[_custom].id = _tokenId.id();\\n        bytes32 _idHash = _tokenId.keccak();\\n        canonicalToRepresentation[_idHash] = _custom;\\n    }\\n\\n    /**\\n     * @notice Migrate all tokens in a previous representation to the latest\\n     * custom representation. This works by looking up local mappings and then\\n     * burning old tokens and minting new tokens.\\n     * @dev This is explicitly opt-in to allow dapps to decide when and how to\\n     * upgrade to the new representation.\\n     * @param _oldRepr The address of the old token to migrate\\n     */\\n    function migrate(address _oldRepr) external {\\n        // get the token ID for the old token contract\\n        TokenId memory _id = representationToCanonical[_oldRepr];\\n        require(_id.domain != 0, \\\"!repr\\\");\\n        // ensure that new token & old token are different\\n        IBridgeToken _old = IBridgeToken(_oldRepr);\\n        IBridgeToken _new = _representationForCanonical(_id);\\n        require(_new != _old, \\\"!different\\\");\\n        // burn the old tokens & mint the new ones\\n        uint256 _bal = _old.balanceOf(msg.sender);\\n        _old.burn(msg.sender, _bal);\\n        _new.mint(msg.sender, _bal);\\n    }\\n\\n    // ============ Internal: Send / UpdateDetails ============\\n\\n    /**\\n     * @notice Given a tokenAddress, format the tokenId\\n     * identifier for the message.\\n     * @param _token The token address\\n     * @param _tokenId The bytes-encoded tokenId\\n     */\\n    function _formatTokenId(address _token)\\n        internal\\n        view\\n        returns (bytes29 _tokenId)\\n    {\\n        TokenId memory _tokId = _tokenIdFor(_token);\\n        _tokenId = BridgeMessage.formatTokenId(_tokId.domain, _tokId.id);\\n    }\\n\\n    // ============ Internal: Handle ============\\n\\n    /**\\n     * @notice Handles an incoming Transfer message.\\n     *\\n     * If the token is of local origin, the amount is sent from escrow.\\n     * Otherwise, a representation token is minted.\\n     *\\n     * @param _tokenId The token ID\\n     * @param _action The action\\n     */\\n    function _handleTransfer(bytes29 _tokenId, bytes29 _action) internal {\\n        // get the token contract for the given tokenId on this chain;\\n        // (if the token is of remote origin and there is\\n        // no existing representation token contract, the TokenRegistry will\\n        // deploy a new one)\\n        IERC20 _token = _ensureToken(_tokenId);\\n        address _recipient = _action.evmRecipient();\\n        // If an LP has prefilled this token transfer,\\n        // send the tokens to the LP instead of the recipient\\n        bytes32 _id = _preFillId(_tokenId, _action);\\n        address _lp = liquidityProvider[_id];\\n        if (_lp != address(0)) {\\n            _recipient = _lp;\\n            delete liquidityProvider[_id];\\n        }\\n        // send the tokens into circulation on this chain\\n        if (_isLocalOrigin(_token)) {\\n            // if the token is of local origin, the tokens have been held in\\n            // escrow in this contract\\n            // while they have been circulating on remote chains;\\n            // transfer the tokens to the recipient\\n            _token.safeTransfer(_recipient, _action.amnt());\\n        } else {\\n            // if the token is of remote origin, mint the tokens to the\\n            // recipient on this chain\\n            _downcast(_token).mint(_recipient, _action.amnt());\\n        }\\n    }\\n\\n    /**\\n     * @notice Handles an incoming Details message.\\n     * @param _tokenId The token ID\\n     * @param _action The action\\n     */\\n    function _handleDetails(bytes29 _tokenId, bytes29 _action) internal {\\n        // get the token contract deployed on this chain\\n        // revert if no token contract exists\\n        IERC20 _token = _mustHaveToken(_tokenId);\\n        // require that the token is of remote origin\\n        // (otherwise, the BridgeRouter did not deploy the token contract,\\n        // and therefore cannot update its metadata)\\n        require(!_isLocalOrigin(_token), \\\"!remote origin\\\");\\n        // update the token metadata\\n        _downcast(_token).setDetails(\\n            TypeCasts.coerceString(_action.name()),\\n            TypeCasts.coerceString(_action.symbol()),\\n            _action.decimals()\\n        );\\n    }\\n\\n    /**\\n     * @notice Handles an incoming RequestDetails message by sending an\\n     *         UpdateDetails message to the remote chain\\n     * @dev The origin and remote are pre-checked by the handle function\\n     *      `onlyRemoteRouter` modifier and can be used without additional check\\n     * @param _messageOrigin The domain from which the message arrived\\n     * @param _messageRemoteRouter The remote router that sent the message\\n     * @param _tokenId The token ID\\n     */\\n    function _handleRequestDetails(\\n        uint32 _messageOrigin,\\n        bytes32 _messageRemoteRouter,\\n        bytes29 _tokenId\\n    ) internal {\\n        // get token & ensure is of local origin\\n        address _token = _tokenId.evmId();\\n        require(_isLocalOrigin(_token), \\\"!local origin\\\");\\n        IBridgeToken _bridgeToken = IBridgeToken(_token);\\n        // format Update Details message\\n        bytes29 _updateDetailsAction = BridgeMessage.formatDetails(\\n            TypeCasts.coerceBytes32(_bridgeToken.name()),\\n            TypeCasts.coerceBytes32(_bridgeToken.symbol()),\\n            _bridgeToken.decimals()\\n        );\\n        // send message to remote chain via Optics\\n        Home(xAppConnectionManager.home()).dispatch(\\n            _messageOrigin,\\n            _messageRemoteRouter,\\n            BridgeMessage.formatMessage(_tokenId, _updateDetailsAction)\\n        );\\n    }\\n\\n    // ============ Internal: Transfer ============\\n\\n    function _ensureToken(bytes29 _tokenId) internal returns (IERC20) {\\n        address _local = _getTokenAddress(_tokenId);\\n        if (_local == address(0)) {\\n            // Representation does not exist yet;\\n            // deploy representation contract\\n            _local = _deployToken(_tokenId);\\n            // message the origin domain\\n            // to request the token details\\n            _requestDetails(_tokenId);\\n        }\\n        return IERC20(_local);\\n    }\\n\\n    // ============ Internal: Request Details ============\\n\\n    /**\\n     * @notice Handles an incoming Details message.\\n     * @param _tokenId The token ID\\n     */\\n    function _requestDetails(bytes29 _tokenId) internal {\\n        uint32 _destination = _tokenId.domain();\\n        // get remote BridgeRouter address; revert if not found\\n        bytes32 _remote = remotes[_destination];\\n        if (_remote == bytes32(0)) {\\n            return;\\n        }\\n        // format Request Details message\\n        bytes29 _action = BridgeMessage.formatRequestDetails();\\n        // send message to remote chain via Optics\\n        Home(xAppConnectionManager.home()).dispatch(\\n            _destination,\\n            _remote,\\n            BridgeMessage.formatMessage(_tokenId, _action)\\n        );\\n    }\\n\\n    // ============ Internal: Fast Liquidity ============\\n\\n    /**\\n     * @notice Calculate the token amount after\\n     * taking a 5 bps (0.05%) liquidity provider fee\\n     * @param _amnt The token amount before the fee is taken\\n     * @return _amtAfterFee The token amount after the fee is taken\\n     */\\n    function _applyPreFillFee(uint256 _amnt)\\n        internal\\n        pure\\n        returns (uint256 _amtAfterFee)\\n    {\\n        // overflow only possible if (2**256 / 9995) tokens sent once\\n        // in which case, probably not a real token\\n        _amtAfterFee =\\n            (_amnt * PRE_FILL_FEE_NUMERATOR) /\\n            PRE_FILL_FEE_DENOMINATOR;\\n    }\\n\\n    /**\\n     * @notice get the prefillId used to identify\\n     * fast liquidity provision for incoming token send messages\\n     * @dev used to identify a token/transfer pair in the prefill LP mapping.\\n     * NOTE: This approach has a weakness: a user can receive >1 batch of tokens of\\n     * the same size, but only 1 will be eligible for fast liquidity. The\\n     * other may only be filled at regular speed. This is because the messages\\n     * will have identical `tokenId` and `action` fields. This seems fine,\\n     * tbqh. A delay of a few hours on a corner case is acceptable in v1.\\n     * @param _tokenId The token ID\\n     * @param _action The action\\n     */\\n    function _preFillId(bytes29 _tokenId, bytes29 _action)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes29[] memory _views = new bytes29[](2);\\n        _views[0] = _tokenId;\\n        _views[1] = _action;\\n        return TypedMemView.joinKeccak(_views);\\n    }\\n\\n    /**\\n     * @dev explicit override for compiler inheritance\\n     * @dev explicit override for compiler inheritance\\n     * @return domain of chain on which the contract is deployed\\n     */\\n    function _localDomain()\\n        internal\\n        view\\n        override(TokenRegistry, XAppConnectionClient)\\n        returns (uint32)\\n    {\\n        return XAppConnectionClient._localDomain();\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/bridge/IWeth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\ninterface IWeth {\\n    function deposit() external payable;\\n\\n    function approve(address _who, uint256 _wad) external;\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/XAppConnectionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {Home} from \\\"./Home.sol\\\";\\nimport {Replica} from \\\"./Replica.sol\\\";\\nimport {TypeCasts} from \\\"../libs/TypeCasts.sol\\\";\\n// ============ External Imports ============\\nimport {ECDSA} from \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title XAppConnectionManager\\n * @author Celo Labs Inc.\\n * @notice Manages a registry of local Replica contracts\\n * for remote Home domains. Accepts Watcher signatures\\n * to un-enroll Replicas attached to fraudulent remote Homes\\n */\\ncontract XAppConnectionManager is Ownable {\\n    // ============ Public Storage ============\\n\\n    // Home contract\\n    Home public home;\\n    // local Replica address => remote Home domain\\n    mapping(address => uint32) public replicaToDomain;\\n    // remote Home domain => local Replica address\\n    mapping(uint32 => address) public domainToReplica;\\n    // watcher address => replica remote domain => has/doesn't have permission\\n    mapping(address => mapping(uint32 => bool)) private watcherPermissions;\\n\\n    // ============ Events ============\\n\\n    /**\\n     * @notice Emitted when a new Replica is enrolled / added\\n     * @param domain the remote domain of the Home contract for the Replica\\n     * @param replica the address of the Replica\\n     */\\n    event ReplicaEnrolled(uint32 indexed domain, address replica);\\n\\n    /**\\n     * @notice Emitted when a new Replica is un-enrolled / removed\\n     * @param domain the remote domain of the Home contract for the Replica\\n     * @param replica the address of the Replica\\n     */\\n    event ReplicaUnenrolled(uint32 indexed domain, address replica);\\n\\n    /**\\n     * @notice Emitted when Watcher permissions are changed\\n     * @param domain the remote domain of the Home contract for the Replica\\n     * @param watcher the address of the Watcher\\n     * @param access TRUE if the Watcher was given permissions, FALSE if permissions were removed\\n     */\\n    event WatcherPermissionSet(\\n        uint32 indexed domain,\\n        address watcher,\\n        bool access\\n    );\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyReplica() {\\n        require(isReplica(msg.sender), \\\"!replica\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() Ownable() {}\\n\\n    // ============ External Functions ============\\n\\n    /**\\n     * @notice Un-Enroll a replica contract\\n     * in the case that fraud was detected on the Home\\n     * @dev in the future, if fraud occurs on the Home contract,\\n     * the Watcher will submit their signature directly to the Home\\n     * and it can be relayed to all remote chains to un-enroll the Replicas\\n     * @param _domain the remote domain of the Home contract for the Replica\\n     * @param _updater the address of the Updater for the Home contract (also stored on Replica)\\n     * @param _signature signature of watcher on (domain, replica address, updater address)\\n     */\\n    function unenrollReplica(\\n        uint32 _domain,\\n        bytes32 _updater,\\n        bytes memory _signature\\n    ) external {\\n        // ensure that the replica is currently set\\n        address _replica = domainToReplica[_domain];\\n        require(_replica != address(0), \\\"!replica exists\\\");\\n        // ensure that the signature is on the proper updater\\n        require(\\n            Replica(_replica).updater() == TypeCasts.bytes32ToAddress(_updater),\\n            \\\"!current updater\\\"\\n        );\\n        // get the watcher address from the signature\\n        // and ensure that the watcher has permission to un-enroll this replica\\n        address _watcher = _recoverWatcherFromSig(\\n            _domain,\\n            TypeCasts.addressToBytes32(_replica),\\n            _updater,\\n            _signature\\n        );\\n        require(watcherPermissions[_watcher][_domain], \\\"!valid watcher\\\");\\n        // remove the replica from mappings\\n        _unenrollReplica(_replica);\\n    }\\n\\n    /**\\n     * @notice Set the address of the local Home contract\\n     * @param _home the address of the local Home contract\\n     */\\n    function setHome(address _home) external onlyOwner {\\n        home = Home(_home);\\n    }\\n\\n    /**\\n     * @notice Allow Owner to enroll Replica contract\\n     * @param _replica the address of the Replica\\n     * @param _domain the remote domain of the Home contract for the Replica\\n     */\\n    function ownerEnrollReplica(address _replica, uint32 _domain)\\n        external\\n        onlyOwner\\n    {\\n        // un-enroll any existing replica\\n        _unenrollReplica(_replica);\\n        // add replica and domain to two-way mapping\\n        replicaToDomain[_replica] = _domain;\\n        domainToReplica[_domain] = _replica;\\n        emit ReplicaEnrolled(_domain, _replica);\\n    }\\n\\n    /**\\n     * @notice Allow Owner to un-enroll Replica contract\\n     * @param _replica the address of the Replica\\n     */\\n    function ownerUnenrollReplica(address _replica) external onlyOwner {\\n        _unenrollReplica(_replica);\\n    }\\n\\n    /**\\n     * @notice Allow Owner to set Watcher permissions for a Replica\\n     * @param _watcher the address of the Watcher\\n     * @param _domain the remote domain of the Home contract for the Replica\\n     * @param _access TRUE to give the Watcher permissions, FALSE to remove permissions\\n     */\\n    function setWatcherPermission(\\n        address _watcher,\\n        uint32 _domain,\\n        bool _access\\n    ) external onlyOwner {\\n        watcherPermissions[_watcher][_domain] = _access;\\n        emit WatcherPermissionSet(_domain, _watcher, _access);\\n    }\\n\\n    /**\\n     * @notice Query local domain from Home\\n     * @return local domain\\n     */\\n    function localDomain() external view returns (uint32) {\\n        return home.localDomain();\\n    }\\n\\n    /**\\n     * @notice Get access permissions for the watcher on the domain\\n     * @param _watcher the address of the watcher\\n     * @param _domain the domain to check for watcher permissions\\n     * @return TRUE iff _watcher has permission to un-enroll replicas on _domain\\n     */\\n    function watcherPermission(address _watcher, uint32 _domain)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return watcherPermissions[_watcher][_domain];\\n    }\\n\\n    // ============ Public Functions ============\\n\\n    /**\\n     * @notice Check whether _replica is enrolled\\n     * @param _replica the replica to check for enrollment\\n     * @return TRUE iff _replica is enrolled\\n     */\\n    function isReplica(address _replica) public view returns (bool) {\\n        return replicaToDomain[_replica] != 0;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    /**\\n     * @notice Remove the replica from the two-way mappings\\n     * @param _replica replica to un-enroll\\n     */\\n    function _unenrollReplica(address _replica) internal {\\n        uint32 _currentDomain = replicaToDomain[_replica];\\n        domainToReplica[_currentDomain] = address(0);\\n        replicaToDomain[_replica] = 0;\\n        emit ReplicaUnenrolled(_currentDomain, _replica);\\n    }\\n\\n    /**\\n     * @notice Get the Watcher address from the provided signature\\n     * @return address of watcher that signed\\n     */\\n    function _recoverWatcherFromSig(\\n        uint32 _domain,\\n        bytes32 _replica,\\n        bytes32 _updater,\\n        bytes memory _signature\\n    ) internal view returns (address) {\\n        bytes32 _homeDomainHash = Replica(TypeCasts.bytes32ToAddress(_replica))\\n            .homeDomainHash();\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(_homeDomainHash, _domain, _updater)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return ECDSA.recover(_digest, _signature);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/TokenRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {BridgeMessage} from \\\"./BridgeMessage.sol\\\";\\nimport {Encoding} from \\\"./Encoding.sol\\\";\\nimport {IBridgeToken} from \\\"../../interfaces/bridge/IBridgeToken.sol\\\";\\nimport {XAppConnectionClient} from \\\"../XAppConnectionClient.sol\\\";\\n// ============ External Imports ============\\nimport {TypeCasts} from \\\"@celo-org/optics-sol/contracts/XAppConnectionManager.sol\\\";\\nimport {UpgradeBeaconProxy} from \\\"@celo-org/optics-sol/contracts/upgrade/UpgradeBeaconProxy.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {TypedMemView} from \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\n/**\\n * @title TokenRegistry\\n * @notice manages a registry of token contracts on this chain\\n * -\\n * We sort token types as \\\"representation token\\\" or \\\"locally originating token\\\".\\n * Locally originating - a token contract that was originally deployed on the local chain\\n * Representation (repr) - a token that was originally deployed on some other chain\\n * -\\n * When the router handles an incoming message, it determines whether the\\n * transfer is for an asset of local origin. If not, it checks for an existing\\n * representation contract. If no such representation exists, it deploys a new\\n * representation contract. It then stores the relationship in the\\n * \\\"reprToCanonical\\\" and \\\"canonicalToRepr\\\" mappings to ensure we can always\\n * perform a lookup in either direction\\n * Note that locally originating tokens should NEVER be represented in these lookup tables.\\n */\\nabstract contract TokenRegistry is Initializable {\\n    // ============ Libraries ============\\n\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n    using BridgeMessage for bytes29;\\n\\n    // ============ Structs ============\\n\\n    // Tokens are identified by a TokenId:\\n    // domain - 4 byte chain ID of the chain from which the token originates\\n    // id - 32 byte identifier of the token address on the origin chain, in that chain's address format\\n    struct TokenId {\\n        uint32 domain;\\n        bytes32 id;\\n    }\\n\\n    // ============ Public Storage ============\\n\\n    // UpgradeBeacon from which new token proxies will get their implementation\\n    address public tokenBeacon;\\n    // local representation token address => token ID\\n    mapping(address => TokenId) public representationToCanonical;\\n    // hash of the tightly-packed TokenId => local representation token address\\n    // If the token is of local origin, this MUST map to address(0).\\n    mapping(bytes32 => address) public canonicalToRepresentation;\\n\\n    // ============ Events ============\\n\\n    event TokenDeployed(\\n        uint32 indexed domain,\\n        bytes32 indexed id,\\n        address indexed representation\\n    );\\n\\n    // ======== Initializer =========\\n\\n    /**\\n     * @notice Initialize the TokenRegistry with UpgradeBeaconController and\\n     * XappConnectionManager.\\n     * @dev This method deploys two new contracts, and may be expensive to call.\\n     * @param _tokenBeacon The address of the upgrade beacon for bridge token\\n     * proxies\\n     */\\n    function __TokenRegistry_initialize(address _tokenBeacon)\\n        internal\\n        initializer\\n    {\\n        tokenBeacon = _tokenBeacon;\\n    }\\n\\n    // ======== External: Token Lookup Convenience =========\\n\\n    /**\\n     * @notice Looks up the canonical identifier for a local representation.\\n     * @dev If no such canonical ID is known, this instead returns (0, bytes32(0))\\n     * @param _local The local address of the representation\\n     */\\n    function getCanonicalAddress(address _local)\\n        external\\n        view\\n        returns (uint32 _domain, bytes32 _id)\\n    {\\n        TokenId memory _canonical = representationToCanonical[_local];\\n        _domain = _canonical.domain;\\n        _id = _canonical.id;\\n    }\\n\\n    /**\\n     * @notice Looks up the local address corresponding to a domain/id pair.\\n     * @dev If the token is local, it will return the local address.\\n     * If the token is non-local and no local representation exists, this\\n     * will return `address(0)`.\\n     * @param _domain the domain of the canonical version.\\n     * @param _id the identifier of the canonical version in its domain.\\n     * @return _token the local address of the token contract\\n     */\\n    function getLocalAddress(uint32 _domain, address _id)\\n        external\\n        view\\n        returns (address _token)\\n    {\\n        _token = getLocalAddress(_domain, TypeCasts.addressToBytes32(_id));\\n    }\\n\\n    // ======== Public: Token Lookup Convenience =========\\n\\n    /**\\n     * @notice Looks up the local address corresponding to a domain/id pair.\\n     * @dev If the token is local, it will return the local address.\\n     * If the token is non-local and no local representation exists, this\\n     * will return `address(0)`.\\n     * @param _domain the domain of the canonical version.\\n     * @param _id the identifier of the canonical version in its domain.\\n     * @return _token the local address of the token contract\\n     */\\n    function getLocalAddress(uint32 _domain, bytes32 _id)\\n        public\\n        view\\n        returns (address _token)\\n    {\\n        _token = _getTokenAddress(BridgeMessage.formatTokenId(_domain, _id));\\n    }\\n\\n    // ======== Internal Functions =========\\n\\n    function _localDomain() internal view virtual returns (uint32);\\n\\n    /**\\n     * @notice Get default name and details for a token\\n     * Sets name to \\\"optics.[domain].[id]\\\"\\n     * and symbol to\\n     * @param _tokenId the tokenId for the token\\n     */\\n    function _defaultDetails(bytes29 _tokenId)\\n        internal\\n        pure\\n        returns (string memory _name, string memory _symbol)\\n    {\\n        // get the first and second half of the token ID\\n        (, uint256 _secondHalfId) = Encoding.encodeHex(uint256(_tokenId.id()));\\n        // encode the default token name: \\\"[decimal domain].[hex 4 bytes of ID]\\\"\\n        _name = string(\\n            abi.encodePacked(\\n                Encoding.decimalUint32(_tokenId.domain()), // 10\\n                \\\".\\\", // 1\\n                uint32(_secondHalfId) // 4\\n            )\\n        );\\n        // allocate the memory for a new 32-byte string\\n        _symbol = new string(10 + 1 + 4);\\n        assembly {\\n            mstore(add(_symbol, 0x20), mload(add(_name, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Deploy and initialize a new token contract\\n     * @dev Each token contract is a proxy which\\n     * points to the token upgrade beacon\\n     * @return _token the address of the token contract\\n     */\\n    function _deployToken(bytes29 _tokenId) internal returns (address _token) {\\n        // deploy and initialize the token contract\\n        _token = address(new UpgradeBeaconProxy(tokenBeacon, \\\"\\\"));\\n        // initialize the token separately from the\\n        IBridgeToken(_token).initialize();\\n        // set the default token name & symbol\\n        string memory _name;\\n        string memory _symbol;\\n        (_name, _symbol) = _defaultDetails(_tokenId);\\n        IBridgeToken(_token).setDetails(_name, _symbol, 18);\\n        // store token in mappings\\n        representationToCanonical[_token].domain = _tokenId.domain();\\n        representationToCanonical[_token].id = _tokenId.id();\\n        canonicalToRepresentation[_tokenId.keccak()] = _token;\\n        // emit event upon deploying new token\\n        emit TokenDeployed(_tokenId.domain(), _tokenId.id(), _token);\\n    }\\n\\n    /**\\n     * @notice Get the local token address\\n     * for the canonical token represented by tokenID\\n     * Returns address(0) if canonical token is of remote origin\\n     * and no representation token has been deployed locally\\n     * @param _tokenId the token id of the canonical token\\n     * @return _local the local token address\\n     */\\n    function _getTokenAddress(bytes29 _tokenId)\\n        internal\\n        view\\n        returns (address _local)\\n    {\\n        if (_tokenId.domain() == _localDomain()) {\\n            // Token is of local origin\\n            _local = _tokenId.evmId();\\n        } else {\\n            // Token is a representation of a token of remote origin\\n            _local = canonicalToRepresentation[_tokenId.keccak()];\\n        }\\n    }\\n\\n    /**\\n     * @notice Return the local token contract for the\\n     * canonical tokenId; revert if there is no local token\\n     * @param _tokenId the token id of the canonical token\\n     * @return the IERC20 token contract\\n     */\\n    function _mustHaveToken(bytes29 _tokenId) internal view returns (IERC20) {\\n        address _local = _getTokenAddress(_tokenId);\\n        require(_local != address(0), \\\"!token\\\");\\n        return IERC20(_local);\\n    }\\n\\n    /**\\n     * @notice Return tokenId for a local token address\\n     * @param _token local token address (representation or canonical)\\n     * @return _id local token address (representation or canonical)\\n     */\\n    function _tokenIdFor(address _token)\\n        internal\\n        view\\n        returns (TokenId memory _id)\\n    {\\n        _id = representationToCanonical[_token];\\n        if (_id.domain == 0) {\\n            _id.domain = _localDomain();\\n            _id.id = TypeCasts.addressToBytes32(_token);\\n        }\\n    }\\n\\n    /**\\n     * @notice Determine if token is of local origin\\n     * @return TRUE if token is locally originating\\n     */\\n    function _isLocalOrigin(IERC20 _token) internal view returns (bool) {\\n        return _isLocalOrigin(address(_token));\\n    }\\n\\n    /**\\n     * @notice Determine if token is of local origin\\n     * @return TRUE if token is locally originating\\n     */\\n    function _isLocalOrigin(address _token) internal view returns (bool) {\\n        // If the contract WAS deployed by the TokenRegistry,\\n        // it will be stored in this mapping.\\n        // If so, it IS NOT of local origin\\n        if (representationToCanonical[_token].domain != 0) {\\n            return false;\\n        }\\n        // If the contract WAS NOT deployed by the TokenRegistry,\\n        // and the contract exists, then it IS of local origin\\n        // Return true if code exists at _addr\\n        uint256 _codeSize;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            _codeSize := extcodesize(_token)\\n        }\\n        return _codeSize != 0;\\n    }\\n\\n    /**\\n     * @notice Get the local representation contract for a canonical token\\n     * @dev Returns contract with null address if tokenId has no representation\\n     * @param _tokenId the tokenId of the canonical token\\n     * @return representation token contract\\n     */\\n    function _representationForCanonical(bytes29 _tokenId)\\n        internal\\n        view\\n        returns (IBridgeToken)\\n    {\\n        return IBridgeToken(canonicalToRepresentation[_tokenId.keccak()]);\\n    }\\n\\n    /**\\n     * @notice Get the local representation contract for a canonical token\\n     * @dev Returns contract with null address if tokenId has no representation\\n     * @param _tokenId the tokenId of the canonical token\\n     * @return representation token contract\\n     */\\n    function _representationForCanonical(TokenId memory _tokenId)\\n        internal\\n        view\\n        returns (IBridgeToken)\\n    {\\n        return _representationForCanonical(_serializeId(_tokenId));\\n    }\\n\\n    /**\\n     * @notice downcast an IERC20 to an IBridgeToken\\n     * @dev Unsafe. Please know what you're doing\\n     * @param _token the IERC20 contract\\n     * @return the IBridgeToken contract\\n     */\\n    function _downcast(IERC20 _token) internal pure returns (IBridgeToken) {\\n        return IBridgeToken(address(_token));\\n    }\\n\\n    /**\\n     * @notice serialize a TokenId struct into a bytes view\\n     * @param _id the tokenId\\n     * @return serialized bytes of tokenId\\n     */\\n    function _serializeId(TokenId memory _id) internal pure returns (bytes29) {\\n        return BridgeMessage.formatTokenId(_id.domain, _id.id);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {XAppConnectionClient} from \\\"./XAppConnectionClient.sol\\\";\\n// ============ External Imports ============\\nimport {IMessageRecipient} from \\\"@celo-org/optics-sol/interfaces/IMessageRecipient.sol\\\";\\n\\nabstract contract Router is XAppConnectionClient, IMessageRecipient {\\n    // ============ Mutable Storage ============\\n\\n    mapping(uint32 => bytes32) public remotes;\\n    uint256[49] private __GAP; // gap for upgrade safety\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @notice Only accept messages from a remote Router contract\\n     * @param _origin The domain the message is coming from\\n     * @param _router The address the message is coming from\\n     */\\n    modifier onlyRemoteRouter(uint32 _origin, bytes32 _router) {\\n        require(_isRemoteRouter(_origin, _router), \\\"!remote router\\\");\\n        _;\\n    }\\n\\n    // ============ External functions ============\\n\\n    /**\\n     * @notice Register the address of a Router contract for the same xApp on a remote chain\\n     * @param _domain The domain of the remote xApp Router\\n     * @param _router The address of the remote xApp Router\\n     */\\n    function enrollRemoteRouter(uint32 _domain, bytes32 _router)\\n        external\\n        onlyOwner\\n    {\\n        remotes[_domain] = _router;\\n    }\\n\\n    // ============ Virtual functions ============\\n\\n    function handle(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes memory _message\\n    ) external virtual override;\\n\\n    // ============ Internal functions ============\\n    /**\\n     * @notice Return true if the given domain / router is the address of a remote xApp Router\\n     * @param _domain The domain of the potential remote xApp Router\\n     * @param _router The address of the potential remote xApp Router\\n     */\\n    function _isRemoteRouter(uint32 _domain, bytes32 _router)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return remotes[_domain] == _router;\\n    }\\n\\n    /**\\n     * @notice Assert that the given domain has a xApp Router registered and return its address\\n     * @param _domain The domain of the chain for which to get the xApp Router\\n     * @return _remote The address of the remote xApp Router on _domain\\n     */\\n    function _mustHaveRemote(uint32 _domain)\\n        internal\\n        view\\n        returns (bytes32 _remote)\\n    {\\n        _remote = remotes[_domain];\\n        require(_remote != bytes32(0), \\\"!remote\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/XAppConnectionClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ External Imports ============\\nimport {Home} from \\\"@celo-org/optics-sol/contracts/Home.sol\\\";\\nimport {XAppConnectionManager} from \\\"@celo-org/optics-sol/contracts/XAppConnectionManager.sol\\\";\\nimport {OwnableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nabstract contract XAppConnectionClient is OwnableUpgradeable {\\n    // ============ Mutable Storage ============\\n\\n    XAppConnectionManager public xAppConnectionManager;\\n    uint256[49] private __GAP; // gap for upgrade safety\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @notice Only accept messages from an Optics Replica contract\\n     */\\n    modifier onlyReplica() {\\n        require(_isReplica(msg.sender), \\\"!replica\\\");\\n        _;\\n    }\\n\\n    // ======== Initializer =========\\n\\n    function __XAppConnectionClient_initialize(address _xAppConnectionManager)\\n        internal\\n        initializer\\n    {\\n        xAppConnectionManager = XAppConnectionManager(_xAppConnectionManager);\\n        __Ownable_init();\\n    }\\n\\n    // ============ External functions ============\\n\\n    /**\\n     * @notice Modify the contract the xApp uses to validate Replica contracts\\n     * @param _xAppConnectionManager The address of the xAppConnectionManager contract\\n     */\\n    function setXAppConnectionManager(address _xAppConnectionManager)\\n        external\\n        onlyOwner\\n    {\\n        xAppConnectionManager = XAppConnectionManager(_xAppConnectionManager);\\n    }\\n\\n    // ============ Internal functions ============\\n\\n    /**\\n     * @notice Get the local Home contract from the xAppConnectionManager\\n     * @return The local Home contract\\n     */\\n    function _home() internal view returns (Home) {\\n        return xAppConnectionManager.home();\\n    }\\n\\n    /**\\n     * @notice Determine whether _potentialReplcia is an enrolled Replica from the xAppConnectionManager\\n     * @return True if _potentialReplica is an enrolled Replica\\n     */\\n    function _isReplica(address _potentialReplica)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return xAppConnectionManager.isReplica(_potentialReplica);\\n    }\\n\\n    /**\\n     * @notice Get the local domain from the xAppConnectionManager\\n     * @return The local domain\\n     */\\n    function _localDomain() internal view virtual returns (uint32) {\\n        return xAppConnectionManager.localDomain();\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/bridge/IBridgeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\ninterface IBridgeToken {\\n    function initialize() external;\\n\\n    function name() external returns (string memory);\\n\\n    function balanceOf(address _account) external view returns (uint256);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function burn(address _from, uint256 _amnt) external;\\n\\n    function mint(address _to, uint256 _amnt) external;\\n\\n    function setDetails(\\n        string calldata _name,\\n        string calldata _symbol,\\n        uint8 _decimals\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/BridgeMessage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ External Imports ============\\nimport {TypedMemView} from \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\n\\nlibrary BridgeMessage {\\n    // ============ Libraries ============\\n\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n\\n    // ============ Enums ============\\n\\n    // WARNING: do NOT re-write the numbers / order\\n    // of message types in an upgrade;\\n    // will cause in-flight messages to be mis-interpreted\\n    enum Types {\\n        Invalid, // 0\\n        TokenId, // 1\\n        Message, // 2\\n        Transfer, // 3\\n        Details, // 4\\n        RequestDetails // 5\\n    }\\n\\n    // ============ Constants ============\\n\\n    uint256 private constant TOKEN_ID_LEN = 36; // 4 bytes domain + 32 bytes id\\n    uint256 private constant IDENTIFIER_LEN = 1;\\n    uint256 private constant TRANSFER_LEN = 65; // 1 byte identifier + 32 bytes recipient + 32 bytes amount\\n    uint256 private constant DETAILS_LEN = 66; // 1 byte identifier + 32 bytes name + 32 bytes symbol + 1 byte decimals\\n    uint256 private constant REQUEST_DETAILS_LEN = 1; // 1 byte identifier\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @notice Asserts a message is of type `_t`\\n     * @param _view The message\\n     * @param _t The expected type\\n     */\\n    modifier typeAssert(bytes29 _view, Types _t) {\\n        _view.assertType(uint40(_t));\\n        _;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    /**\\n     * @notice Checks that Action is valid type\\n     * @param _action The action\\n     * @return TRUE if action is valid\\n     */\\n    function isValidAction(bytes29 _action) internal pure returns (bool) {\\n        return\\n            isDetails(_action) ||\\n            isRequestDetails(_action) ||\\n            isTransfer(_action);\\n    }\\n\\n    /**\\n     * @notice Checks that view is a valid message length\\n     * @param _view The bytes string\\n     * @return TRUE if message is valid\\n     */\\n    function isValidMessageLength(bytes29 _view) internal pure returns (bool) {\\n        uint256 _len = _view.len();\\n        return\\n            _len == TOKEN_ID_LEN + TRANSFER_LEN ||\\n            _len == TOKEN_ID_LEN + DETAILS_LEN ||\\n            _len == TOKEN_ID_LEN + REQUEST_DETAILS_LEN;\\n    }\\n\\n    /**\\n     * @notice Formats an action message\\n     * @param _tokenId The token ID\\n     * @param _action The action\\n     * @return The formatted message\\n     */\\n    function formatMessage(bytes29 _tokenId, bytes29 _action)\\n        internal\\n        view\\n        typeAssert(_tokenId, Types.TokenId)\\n        returns (bytes memory)\\n    {\\n        require(isValidAction(_action), \\\"!action\\\");\\n        bytes29[] memory _views = new bytes29[](2);\\n        _views[0] = _tokenId;\\n        _views[1] = _action;\\n        return TypedMemView.join(_views);\\n    }\\n\\n    /**\\n     * @notice Returns the type of the message\\n     * @param _view The message\\n     * @return The type of the message\\n     */\\n    function messageType(bytes29 _view) internal pure returns (Types) {\\n        return Types(uint8(_view.typeOf()));\\n    }\\n\\n    /**\\n     * @notice Checks that the message is of type Transfer\\n     * @param _action The message\\n     * @return True if the message is of type Transfer\\n     */\\n    function isTransfer(bytes29 _action) internal pure returns (bool) {\\n        return\\n            actionType(_action) == uint8(Types.Transfer) &&\\n            messageType(_action) == Types.Transfer;\\n    }\\n\\n    /**\\n     * @notice Checks that the message is of type Details\\n     * @param _action The message\\n     * @return True if the message is of type Details\\n     */\\n    function isDetails(bytes29 _action) internal pure returns (bool) {\\n        return\\n            actionType(_action) == uint8(Types.Details) &&\\n            messageType(_action) == Types.Details;\\n    }\\n\\n    /**\\n     * @notice Checks that the message is of type Details\\n     * @param _action The message\\n     * @return True if the message is of type Details\\n     */\\n    function isRequestDetails(bytes29 _action) internal pure returns (bool) {\\n        return\\n            actionType(_action) == uint8(Types.RequestDetails) &&\\n            messageType(_action) == Types.RequestDetails;\\n    }\\n\\n    /**\\n     * @notice Formats Transfer\\n     * @param _to The recipient address as bytes32\\n     * @param _amnt The transfer amount\\n     * @return\\n     */\\n    function formatTransfer(bytes32 _to, uint256 _amnt)\\n        internal\\n        pure\\n        returns (bytes29)\\n    {\\n        return\\n            mustBeTransfer(abi.encodePacked(Types.Transfer, _to, _amnt).ref(0));\\n    }\\n\\n    /**\\n     * @notice Formats Details\\n     * @param _name The name\\n     * @param _symbol The symbol\\n     * @param _decimals The decimals\\n     * @return The Details message\\n     */\\n    function formatDetails(\\n        bytes32 _name,\\n        bytes32 _symbol,\\n        uint8 _decimals\\n    ) internal pure returns (bytes29) {\\n        return\\n            mustBeDetails(\\n                abi.encodePacked(Types.Details, _name, _symbol, _decimals).ref(\\n                    0\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Formats Request Details\\n     * @return The Request Details message\\n     */\\n    function formatRequestDetails() internal pure returns (bytes29) {\\n        return\\n            mustBeRequestDetails(abi.encodePacked(Types.RequestDetails).ref(0));\\n    }\\n\\n    /**\\n     * @notice Formats the Token ID\\n     * @param _domain The domain\\n     * @param _id The ID\\n     * @return The formatted Token ID\\n     */\\n    function formatTokenId(uint32 _domain, bytes32 _id)\\n        internal\\n        pure\\n        returns (bytes29)\\n    {\\n        return mustBeTokenId(abi.encodePacked(_domain, _id).ref(0));\\n    }\\n\\n    /**\\n     * @notice Retrieves the domain from a TokenID\\n     * @param _tokenId The message\\n     * @return The domain\\n     */\\n    function domain(bytes29 _tokenId)\\n        internal\\n        pure\\n        typeAssert(_tokenId, Types.TokenId)\\n        returns (uint32)\\n    {\\n        return uint32(_tokenId.indexUint(0, 4));\\n    }\\n\\n    /**\\n     * @notice Retrieves the ID from a TokenID\\n     * @param _tokenId The message\\n     * @return The ID\\n     */\\n    function id(bytes29 _tokenId)\\n        internal\\n        pure\\n        typeAssert(_tokenId, Types.TokenId)\\n        returns (bytes32)\\n    {\\n        // before = 4 bytes domain\\n        return _tokenId.index(4, 32);\\n    }\\n\\n    /**\\n     * @notice Retrieves the EVM ID\\n     * @param _tokenId The message\\n     * @return The EVM ID\\n     */\\n    function evmId(bytes29 _tokenId)\\n        internal\\n        pure\\n        typeAssert(_tokenId, Types.TokenId)\\n        returns (address)\\n    {\\n        // before = 4 bytes domain + 12 bytes empty to trim for address\\n        return _tokenId.indexAddress(16);\\n    }\\n\\n    /**\\n     * @notice Retrieves the action identifier from message\\n     * @param _message The action\\n     * @return The message type\\n     */\\n    function msgType(bytes29 _message) internal pure returns (uint8) {\\n        return uint8(_message.indexUint(TOKEN_ID_LEN, 1));\\n    }\\n\\n    /**\\n     * @notice Retrieves the identifier from action\\n     * @param _action The action\\n     * @return The action type\\n     */\\n    function actionType(bytes29 _action) internal pure returns (uint8) {\\n        return uint8(_action.indexUint(0, 1));\\n    }\\n\\n    /**\\n     * @notice Retrieves the recipient from a Transfer\\n     * @param _transferAction The message\\n     * @return The recipient address as bytes32\\n     */\\n    function recipient(bytes29 _transferAction)\\n        internal\\n        pure\\n        typeAssert(_transferAction, Types.Transfer)\\n        returns (bytes32)\\n    {\\n        // before = 1 byte identifier\\n        return _transferAction.index(1, 32);\\n    }\\n\\n    /**\\n     * @notice Retrieves the EVM Recipient from a Transfer\\n     * @param _transferAction The message\\n     * @return The EVM Recipient\\n     */\\n    function evmRecipient(bytes29 _transferAction)\\n        internal\\n        pure\\n        typeAssert(_transferAction, Types.Transfer)\\n        returns (address)\\n    {\\n        // before = 1 byte identifier + 12 bytes empty to trim for address\\n        return _transferAction.indexAddress(13);\\n    }\\n\\n    /**\\n     * @notice Retrieves the amount from a Transfer\\n     * @param _transferAction The message\\n     * @return The amount\\n     */\\n    function amnt(bytes29 _transferAction)\\n        internal\\n        pure\\n        typeAssert(_transferAction, Types.Transfer)\\n        returns (uint256)\\n    {\\n        // before = 1 byte identifier + 32 bytes ID\\n        return _transferAction.indexUint(33, 32);\\n    }\\n\\n    /**\\n     * @notice Retrieves the name from Details\\n     * @param _detailsAction The message\\n     * @return The name\\n     */\\n    function name(bytes29 _detailsAction)\\n        internal\\n        pure\\n        typeAssert(_detailsAction, Types.Details)\\n        returns (bytes32)\\n    {\\n        // before = 1 byte identifier\\n        return _detailsAction.index(1, 32);\\n    }\\n\\n    /**\\n     * @notice Retrieves the symbol from Details\\n     * @param _detailsAction The message\\n     * @return The symbol\\n     */\\n    function symbol(bytes29 _detailsAction)\\n        internal\\n        pure\\n        typeAssert(_detailsAction, Types.Details)\\n        returns (bytes32)\\n    {\\n        // before = 1 byte identifier + 32 bytes name\\n        return _detailsAction.index(33, 32);\\n    }\\n\\n    /**\\n     * @notice Retrieves the decimals from Details\\n     * @param _detailsAction The message\\n     * @return The decimals\\n     */\\n    function decimals(bytes29 _detailsAction)\\n        internal\\n        pure\\n        typeAssert(_detailsAction, Types.Details)\\n        returns (uint8)\\n    {\\n        // before = 1 byte identifier + 32 bytes name + 32 bytes symbol\\n        return uint8(_detailsAction.indexUint(65, 1));\\n    }\\n\\n    /**\\n     * @notice Retrieves the token ID from a Message\\n     * @param _message The message\\n     * @return The ID\\n     */\\n    function tokenId(bytes29 _message)\\n        internal\\n        pure\\n        typeAssert(_message, Types.Message)\\n        returns (bytes29)\\n    {\\n        return _message.slice(0, TOKEN_ID_LEN, uint40(Types.TokenId));\\n    }\\n\\n    /**\\n     * @notice Retrieves the action data from a Message\\n     * @param _message The message\\n     * @return The action\\n     */\\n    function action(bytes29 _message)\\n        internal\\n        pure\\n        typeAssert(_message, Types.Message)\\n        returns (bytes29)\\n    {\\n        uint256 _actionLen = _message.len() - TOKEN_ID_LEN;\\n        uint40 _type = uint40(msgType(_message));\\n        return _message.slice(TOKEN_ID_LEN, _actionLen, _type);\\n    }\\n\\n    /**\\n     * @notice Converts to a Transfer\\n     * @param _action The message\\n     * @return The newly typed message\\n     */\\n    function tryAsTransfer(bytes29 _action) internal pure returns (bytes29) {\\n        if (_action.len() == TRANSFER_LEN) {\\n            return _action.castTo(uint40(Types.Transfer));\\n        }\\n        return TypedMemView.nullView();\\n    }\\n\\n    /**\\n     * @notice Converts to a Details\\n     * @param _action The message\\n     * @return The newly typed message\\n     */\\n    function tryAsDetails(bytes29 _action) internal pure returns (bytes29) {\\n        if (_action.len() == DETAILS_LEN) {\\n            return _action.castTo(uint40(Types.Details));\\n        }\\n        return TypedMemView.nullView();\\n    }\\n\\n    /**\\n     * @notice Converts to a Details\\n     * @param _action The message\\n     * @return The newly typed message\\n     */\\n    function tryAsRequestDetails(bytes29 _action)\\n        internal\\n        pure\\n        returns (bytes29)\\n    {\\n        if (_action.len() == REQUEST_DETAILS_LEN) {\\n            return _action.castTo(uint40(Types.RequestDetails));\\n        }\\n        return TypedMemView.nullView();\\n    }\\n\\n    /**\\n     * @notice Converts to a TokenID\\n     * @param _tokenId The message\\n     * @return The newly typed message\\n     */\\n    function tryAsTokenId(bytes29 _tokenId) internal pure returns (bytes29) {\\n        if (_tokenId.len() == TOKEN_ID_LEN) {\\n            return _tokenId.castTo(uint40(Types.TokenId));\\n        }\\n        return TypedMemView.nullView();\\n    }\\n\\n    /**\\n     * @notice Converts to a Message\\n     * @param _message The message\\n     * @return The newly typed message\\n     */\\n    function tryAsMessage(bytes29 _message) internal pure returns (bytes29) {\\n        if (isValidMessageLength(_message)) {\\n            return _message.castTo(uint40(Types.Message));\\n        }\\n        return TypedMemView.nullView();\\n    }\\n\\n    /**\\n     * @notice Asserts that the message is of type Transfer\\n     * @param _view The message\\n     * @return The message\\n     */\\n    function mustBeTransfer(bytes29 _view) internal pure returns (bytes29) {\\n        return tryAsTransfer(_view).assertValid();\\n    }\\n\\n    /**\\n     * @notice Asserts that the message is of type Details\\n     * @param _view The message\\n     * @return The message\\n     */\\n    function mustBeDetails(bytes29 _view) internal pure returns (bytes29) {\\n        return tryAsDetails(_view).assertValid();\\n    }\\n\\n    /**\\n     * @notice Asserts that the message is of type Details\\n     * @param _view The message\\n     * @return The message\\n     */\\n    function mustBeRequestDetails(bytes29 _view)\\n        internal\\n        pure\\n        returns (bytes29)\\n    {\\n        return tryAsRequestDetails(_view).assertValid();\\n    }\\n\\n    /**\\n     * @notice Asserts that the message is of type TokenID\\n     * @param _view The message\\n     * @return The message\\n     */\\n    function mustBeTokenId(bytes29 _view) internal pure returns (bytes29) {\\n        return tryAsTokenId(_view).assertValid();\\n    }\\n\\n    /**\\n     * @notice Asserts that the message is of type Message\\n     * @param _view The message\\n     * @return The message\\n     */\\n    function mustBeMessage(bytes29 _view) internal pure returns (bytes29) {\\n        return tryAsMessage(_view).assertValid();\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/Home.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {Version0} from \\\"./Version0.sol\\\";\\nimport {Common} from \\\"./Common.sol\\\";\\nimport {QueueLib} from \\\"../libs/Queue.sol\\\";\\nimport {MerkleLib} from \\\"../libs/Merkle.sol\\\";\\nimport {Message} from \\\"../libs/Message.sol\\\";\\nimport {MerkleTreeManager} from \\\"./Merkle.sol\\\";\\nimport {QueueManager} from \\\"./Queue.sol\\\";\\nimport {IUpdaterManager} from \\\"../interfaces/IUpdaterManager.sol\\\";\\n// ============ External Imports ============\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {OwnableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\n/**\\n * @title Home\\n * @author Celo Labs Inc.\\n * @notice Accepts messages to be dispatched to remote chains,\\n * constructs a Merkle tree of the messages,\\n * and accepts signatures from a bonded Updater\\n * which notarize the Merkle tree roots.\\n * Accepts submissions of fraudulent signatures\\n * by the Updater and slashes the Updater in this case.\\n */\\ncontract Home is\\n    Version0,\\n    QueueManager,\\n    MerkleTreeManager,\\n    Common,\\n    OwnableUpgradeable\\n{\\n    // ============ Libraries ============\\n\\n    using QueueLib for QueueLib.Queue;\\n    using MerkleLib for MerkleLib.Tree;\\n\\n    // ============ Constants ============\\n\\n    // Maximum bytes per message = 2 KiB\\n    // (somewhat arbitrarily set to begin)\\n    uint256 public constant MAX_MESSAGE_BODY_BYTES = 2 * 2**10;\\n\\n    // ============ Public Storage Variables ============\\n\\n    // domain => next available nonce for the domain\\n    mapping(uint32 => uint32) public nonces;\\n    // contract responsible for Updater bonding, slashing and rotation\\n    IUpdaterManager public updaterManager;\\n\\n    // ============ Upgrade Gap ============\\n\\n    // gap for upgrade safety\\n    uint256[48] private __GAP;\\n\\n    // ============ Events ============\\n\\n    /**\\n     * @notice Emitted when a new message is dispatched via Optics\\n     * @param leafIndex Index of message's leaf in merkle tree\\n     * @param destinationAndNonce Destination and destination-specific\\n     * nonce combined in single field ((destination << 32) & nonce)\\n     * @param messageHash Hash of message; the leaf inserted to the Merkle tree for the message\\n     * @param committedRoot the latest notarized root submitted in the last signed Update\\n     * @param message Raw bytes of message\\n     */\\n    event Dispatch(\\n        bytes32 indexed messageHash,\\n        uint256 indexed leafIndex,\\n        uint64 indexed destinationAndNonce,\\n        bytes32 committedRoot,\\n        bytes message\\n    );\\n\\n    /**\\n     * @notice Emitted when proof of an improper update is submitted,\\n     * which sets the contract to FAILED state\\n     * @param oldRoot Old root of the improper update\\n     * @param newRoot New root of the improper update\\n     * @param signature Signature on `oldRoot` and `newRoot\\n     */\\n    event ImproperUpdate(bytes32 oldRoot, bytes32 newRoot, bytes signature);\\n\\n    /**\\n     * @notice Emitted when the Updater is slashed\\n     * (should be paired with ImproperUpdater or DoubleUpdate event)\\n     * @param updater The address of the updater\\n     * @param reporter The address of the entity that reported the updater misbehavior\\n     */\\n    event UpdaterSlashed(address indexed updater, address indexed reporter);\\n\\n    /**\\n     * @notice Emitted when Updater is rotated by the UpdaterManager\\n     * @param updater The address of the new updater\\n     */\\n    event NewUpdater(address updater);\\n\\n    /**\\n     * @notice Emitted when the UpdaterManager contract is changed\\n     * @param updaterManager The address of the new updaterManager\\n     */\\n    event NewUpdaterManager(address updaterManager);\\n\\n    // ============ Constructor ============\\n\\n    constructor(uint32 _localDomain) Common(_localDomain) {} // solhint-disable-line no-empty-blocks\\n\\n    // ============ Initializer ============\\n\\n    function initialize(IUpdaterManager _updaterManager) public initializer {\\n        // initialize owner & queue\\n        __Ownable_init();\\n        __QueueManager_initialize();\\n        // set Updater Manager contract and initialize Updater\\n        _setUpdaterManager(_updaterManager);\\n        address _updater = updaterManager.updater();\\n        __Common_initialize(_updater);\\n        emit NewUpdater(_updater);\\n    }\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @notice Ensures that function is called by the UpdaterManager contract\\n     */\\n    modifier onlyUpdaterManager() {\\n        require(msg.sender == address(updaterManager), \\\"!updaterManager\\\");\\n        _;\\n    }\\n\\n    // ============ External: Updater & UpdaterManager Configuration  ============\\n\\n    /**\\n     * @notice Set a new Updater\\n     * @param _updater the new Updater\\n     */\\n    function setUpdater(address _updater) external onlyUpdaterManager {\\n        _setUpdater(_updater);\\n    }\\n\\n    /**\\n     * @notice Set a new UpdaterManager contract\\n     * @dev Home(s) will initially be initialized using a trusted UpdaterManager contract;\\n     * we will progressively decentralize by swapping the trusted contract with a new implementation\\n     * that implements Updater bonding & slashing, and rules for Updater selection & rotation\\n     * @param _updaterManager the new UpdaterManager contract\\n     */\\n    function setUpdaterManager(address _updaterManager) external onlyOwner {\\n        _setUpdaterManager(IUpdaterManager(_updaterManager));\\n    }\\n\\n    // ============ External Functions  ============\\n\\n    /**\\n     * @notice Dispatch the message it to the destination domain & recipient\\n     * @dev Format the message, insert its hash into Merkle tree,\\n     * enqueue the new Merkle root, and emit `Dispatch` event with message information.\\n     * @param _destinationDomain Domain of destination chain\\n     * @param _recipientAddress Address of recipient on destination chain as bytes32\\n     * @param _messageBody Raw bytes content of message\\n     */\\n    function dispatch(\\n        uint32 _destinationDomain,\\n        bytes32 _recipientAddress,\\n        bytes memory _messageBody\\n    ) external notFailed {\\n        require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \\\"msg too long\\\");\\n        // get the next nonce for the destination domain, then increment it\\n        uint32 _nonce = nonces[_destinationDomain];\\n        nonces[_destinationDomain] = _nonce + 1;\\n        // format the message into packed bytes\\n        bytes memory _message = Message.formatMessage(\\n            localDomain,\\n            bytes32(uint256(uint160(msg.sender))),\\n            _nonce,\\n            _destinationDomain,\\n            _recipientAddress,\\n            _messageBody\\n        );\\n        // insert the hashed message into the Merkle tree\\n        bytes32 _messageHash = keccak256(_message);\\n        tree.insert(_messageHash);\\n        // enqueue the new Merkle root after inserting the message\\n        queue.enqueue(root());\\n        // Emit Dispatch event with message information\\n        // note: leafIndex is count() - 1 since new leaf has already been inserted\\n        emit Dispatch(\\n            _messageHash,\\n            count() - 1,\\n            _destinationAndNonce(_destinationDomain, _nonce),\\n            committedRoot,\\n            _message\\n        );\\n    }\\n\\n    /**\\n     * @notice Submit a signature from the Updater \\\"notarizing\\\" a root,\\n     * which updates the Home contract's `committedRoot`,\\n     * and publishes the signature which will be relayed to Replica contracts\\n     * @dev emits Update event\\n     * @dev If _newRoot is not contained in the queue,\\n     * the Update is a fraudulent Improper Update, so\\n     * the Updater is slashed & Home is set to FAILED state\\n     * @param _committedRoot Current updated merkle root which the update is building off of\\n     * @param _newRoot New merkle root to update the contract state to\\n     * @param _signature Updater signature on `_committedRoot` and `_newRoot`\\n     */\\n    function update(\\n        bytes32 _committedRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) external notFailed {\\n        // check that the update is not fraudulent;\\n        // if fraud is detected, Updater is slashed & Home is set to FAILED state\\n        if (improperUpdate(_committedRoot, _newRoot, _signature)) return;\\n        // clear all of the intermediate roots contained in this update from the queue\\n        while (true) {\\n            bytes32 _next = queue.dequeue();\\n            if (_next == _newRoot) break;\\n        }\\n        // update the Home state with the latest signed root & emit event\\n        committedRoot = _newRoot;\\n        emit Update(localDomain, _committedRoot, _newRoot, _signature);\\n    }\\n\\n    /**\\n     * @notice Suggest an update for the Updater to sign and submit.\\n     * @dev If queue is empty, null bytes returned for both\\n     * (No update is necessary because no messages have been dispatched since the last update)\\n     * @return _committedRoot Latest root signed by the Updater\\n     * @return _new Latest enqueued Merkle root\\n     */\\n    function suggestUpdate()\\n        external\\n        view\\n        returns (bytes32 _committedRoot, bytes32 _new)\\n    {\\n        if (queue.length() != 0) {\\n            _committedRoot = committedRoot;\\n            _new = queue.lastItem();\\n        }\\n    }\\n\\n    // ============ Public Functions  ============\\n\\n    /**\\n     * @notice Hash of Home domain concatenated with \\\"OPTICS\\\"\\n     */\\n    function homeDomainHash() public view override returns (bytes32) {\\n        return _homeDomainHash(localDomain);\\n    }\\n\\n    /**\\n     * @notice Check if an Update is an Improper Update;\\n     * if so, slash the Updater and set the contract to FAILED state.\\n     *\\n     * An Improper Update is an update building off of the Home's `committedRoot`\\n     * for which the `_newRoot` does not currently exist in the Home's queue.\\n     * This would mean that message(s) that were not truly\\n     * dispatched on Home were falsely included in the signed root.\\n     *\\n     * An Improper Update will only be accepted as valid by the Replica\\n     * If an Improper Update is attempted on Home,\\n     * the Updater will be slashed immediately.\\n     * If an Improper Update is submitted to the Replica,\\n     * it should be relayed to the Home contract using this function\\n     * in order to slash the Updater with an Improper Update.\\n     *\\n     * An Improper Update submitted to the Replica is only valid\\n     * while the `_oldRoot` is still equal to the `committedRoot` on Home;\\n     * if the `committedRoot` on Home has already been updated with a valid Update,\\n     * then the Updater should be slashed with a Double Update.\\n     * @dev Reverts (and doesn't slash updater) if signature is invalid or\\n     * update not current\\n     * @param _oldRoot Old merkle tree root (should equal home's committedRoot)\\n     * @param _newRoot New merkle tree root\\n     * @param _signature Updater signature on `_oldRoot` and `_newRoot`\\n     * @return TRUE if update was an Improper Update (implying Updater was slashed)\\n     */\\n    function improperUpdate(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) public notFailed returns (bool) {\\n        require(\\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\\n            \\\"!updater sig\\\"\\n        );\\n        require(_oldRoot == committedRoot, \\\"not a current update\\\");\\n        // if the _newRoot is not currently contained in the queue,\\n        // slash the Updater and set the contract to FAILED state\\n        if (!queue.contains(_newRoot)) {\\n            _fail();\\n            emit ImproperUpdate(_oldRoot, _newRoot, _signature);\\n            return true;\\n        }\\n        // if the _newRoot is contained in the queue,\\n        // this is not an improper update\\n        return false;\\n    }\\n\\n    // ============ Internal Functions  ============\\n\\n    /**\\n     * @notice Set the UpdaterManager\\n     * @param _updaterManager Address of the UpdaterManager\\n     */\\n    function _setUpdaterManager(IUpdaterManager _updaterManager) internal {\\n        require(\\n            Address.isContract(address(_updaterManager)),\\n            \\\"!contract updaterManager\\\"\\n        );\\n        updaterManager = IUpdaterManager(_updaterManager);\\n        emit NewUpdaterManager(address(_updaterManager));\\n    }\\n\\n    /**\\n     * @notice Set the Updater\\n     * @param _updater Address of the Updater\\n     */\\n    function _setUpdater(address _updater) internal {\\n        updater = _updater;\\n        emit NewUpdater(_updater);\\n    }\\n\\n    /**\\n     * @notice Slash the Updater and set contract state to FAILED\\n     * @dev Called when fraud is proven (Improper Update or Double Update)\\n     */\\n    function _fail() internal override {\\n        // set contract to FAILED\\n        _setFailed();\\n        // slash Updater\\n        updaterManager.slashUpdater(msg.sender);\\n        emit UpdaterSlashed(updater, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Internal utility function that combines\\n     * `_destination` and `_nonce`.\\n     * @dev Both destination and nonce should be less than 2^32 - 1\\n     * @param _destination Domain of destination chain\\n     * @param _nonce Current nonce for given destination chain\\n     * @return Returns (`_destination` << 32) & `_nonce`\\n     */\\n    function _destinationAndNonce(uint32 _destination, uint32 _nonce)\\n        internal\\n        pure\\n        returns (uint64)\\n    {\\n        return (uint64(_destination) << 32) | _nonce;\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/Version0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n/**\\n * @title Version0\\n * @notice Version getter for contracts\\n **/\\ncontract Version0 {\\n    uint8 public constant VERSION = 0;\\n}\\n\"\r\n    },\r\n    \"@summa-tx/memview-sol/contracts/TypedMemView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.5.10;\\n\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\n\\nlibrary TypedMemView {\\n    using SafeMath for uint256;\\n\\n    // Why does this exist?\\n    // the solidity `bytes memory` type has a few weaknesses.\\n    // 1. You can't index ranges effectively\\n    // 2. You can't slice without copying\\n    // 3. The underlying data may represent any type\\n    // 4. Solidity never deallocates memory, and memory costs grow\\n    //    superlinearly\\n\\n    // By using a memory view instead of a `bytes memory` we get the following\\n    // advantages:\\n    // 1. Slices are done on the stack, by manipulating the pointer\\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\\n    // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\\n    // algorithms.\\n\\n    // Why bytes29?\\n    // We want to avoid confusion between views, digests, and other common\\n    // types so we chose a large and uncommonly used odd number of bytes\\n    //\\n    // Note that while bytes are left-aligned in a word, integers and addresses\\n    // are right-aligned. This means when working in assembly we have to\\n    // account for the 3 unused bytes on the righthand side\\n    //\\n    // First 5 bytes are a type flag.\\n    // - ff_ffff_fffe is reserved for unknown type.\\n    // - ff_ffff_ffff is reserved for invalid types/errors.\\n    // next 12 are memory address\\n    // next 12 are len\\n    // bottom 3 bytes are empty\\n\\n    // Assumptions:\\n    // - non-modification of memory.\\n    // - No Solidity updates\\n    // - - wrt free mem point\\n    // - - wrt bytes representation in memory\\n    // - - wrt memory addressing in general\\n\\n    // Usage:\\n    // - create type constants\\n    // - use `assertType` for runtime type assertions\\n    // - - unfortunately we can't do this at compile time yet :(\\n    // - recommended: implement modifiers that perform type checking\\n    // - - e.g.\\n    // - - `uint40 constant MY_TYPE = 3;`\\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n    // - instantiate a typed view from a bytearray using `ref`\\n    // - use `index` to inspect the contents of the view\\n    // - use `slice` to create smaller views into the same memory\\n    // - - `slice` can increase the offset\\n    // - - `slice can decrease the length`\\n    // - - must specify the output type of `slice`\\n    // - - `slice` will return a null view if you try to overrun\\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\\n    // - use `equal` for typed comparisons.\\n\\n\\n    // The null view\\n    bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n    uint8 constant TWELVE_BYTES = 96;\\n\\n    /**\\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n     * @param _b    The byte\\n     * @return      char - The encoded hex character\\n     */\\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\n        // This can probably be done more efficiently, but it's only in error\\n        // paths, so we don't really care :)\\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n        if (_nibble == 0xf0) {return 0x30;} // 0\\n        if (_nibble == 0xf1) {return 0x31;} // 1\\n        if (_nibble == 0xf2) {return 0x32;} // 2\\n        if (_nibble == 0xf3) {return 0x33;} // 3\\n        if (_nibble == 0xf4) {return 0x34;} // 4\\n        if (_nibble == 0xf5) {return 0x35;} // 5\\n        if (_nibble == 0xf6) {return 0x36;} // 6\\n        if (_nibble == 0xf7) {return 0x37;} // 7\\n        if (_nibble == 0xf8) {return 0x38;} // 8\\n        if (_nibble == 0xf9) {return 0x39;} // 9\\n        if (_nibble == 0xfa) {return 0x61;} // a\\n        if (_nibble == 0xfb) {return 0x62;} // b\\n        if (_nibble == 0xfc) {return 0x63;} // c\\n        if (_nibble == 0xfd) {return 0x64;} // d\\n        if (_nibble == 0xfe) {return 0x65;} // e\\n        if (_nibble == 0xff) {return 0x66;} // f\\n    }\\n\\n    /**\\n     * @notice      Returns a uint16 containing the hex-encoded byte.\\n     * @param _b    The byte\\n     * @return      encoded - The hex-encoded byte\\n     */\\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\\n        encoded <<= 8;\\n        encoded |= nibbleHex(_b); // lower 4 bits\\n    }\\n\\n    /**\\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n     *              `second` contains the encoded lower 16 bytes.\\n     *\\n     * @param _b    The 32 bytes as uint256\\n     * @return      first - The top 16 bytes\\n     * @return      second - The bottom 16 bytes\\n     */\\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n        for (uint8 i = 31; i > 15; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            first |= byteHex(_byte);\\n            if (i != 16) {\\n                first <<= 16;\\n            }\\n        }\\n\\n        // abusing underflow here =_=\\n        for (uint8 i = 15; i < 255 ; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            second |= byteHex(_byte);\\n            if (i != 0) {\\n                second <<= 16;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice          Changes the endianness of a uint256.\\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n     * @param _b        The unsigned integer to reverse\\n     * @return          v - The reversed value\\n     */\\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n        v = _b;\\n\\n        // swap bytes\\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n        // swap 2-byte long pairs\\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n        // swap 4-byte long pairs\\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n        // swap 8-byte long pairs\\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    /**\\n     * @notice      Create a mask with the highest `_len` bits set.\\n     * @param _len  The length\\n     * @return      mask - The mask\\n     */\\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n        // ugly. redo without assembly?\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mask := sar(\\n                sub(_len, 1),\\n                0x8000000000000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice      Return the null view.\\n     * @return      bytes29 - The null view\\n     */\\n    function nullView() internal pure returns (bytes29) {\\n        return NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is null.\\n     * @return      bool - True if the view is null\\n     */\\n    function isNull(bytes29 memView) internal pure returns (bool) {\\n        return memView == NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is not null.\\n     * @return      bool - True if the view is not null\\n     */\\n    function notNull(bytes29 memView) internal pure returns (bool) {\\n        return !isNull(memView);\\n    }\\n\\n    /**\\n     * @notice          Check if the view is of a valid type and points to a valid location\\n     *                  in memory.\\n     * @dev             We perform this check by examining solidity's unallocated memory\\n     *                  pointer and ensuring that the view's upper bound is less than that.\\n     * @param memView   The view\\n     * @return          ret - True if the view is valid\\n     */\\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\\n        if (typeOf(memView) == 0xffffffffff) {return false;}\\n        uint256 _end = end(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ret := not(gt(_end, mload(0x40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view be valid.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @return          bytes29 - The validated view\\n     */\\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n        require(isValid(memView), \\\"Validity assertion failed\\\");\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bool - True if the memview is of the expected type\\n     */\\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n        return typeOf(memView) == _expected;\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view has a specific type.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bytes29 - The view with validated type\\n     */\\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n        if (!isType(memView, _expected)) {\\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n            (, uint256 e) = encodeHex(uint256(_expected));\\n            string memory err = string(\\n                abi.encodePacked(\\n                    \\\"Type assertion failed. Got 0x\\\",\\n                    uint80(g),\\n                    \\\". Expected 0x\\\",\\n                    uint80(e)\\n                )\\n            );\\n            revert(err);\\n        }\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return an identical view with a different type.\\n     * @param memView   The view\\n     * @param _newType  The new type\\n     * @return          newView - The new view with the specified type\\n     */\\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n        // then | in the new type\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // shift off the top 5 bytes\\n            newView := or(newView, shr(40, shl(40, memView)))\\n            newView := or(newView, shl(216, _newType))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            newView := shl(96, or(newView, _type)) // insert type\\n            newView := shl(96, or(newView, _loc))  // insert loc\\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {\\n        uint256 _end = _loc.add(_len);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            if gt(_end, mload(0x40)) {\\n                _end := 0\\n            }\\n        }\\n        if (_end == 0) {\\n            return NULL;\\n        }\\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Instantiate a memory view from a byte array.\\n     * @dev             Note that due to Solidity memory representation, it is not possible to\\n     *                  implement a deref, as the `bytes` type stores its len in memory.\\n     * @param arr       The byte array\\n     * @param newType   The type\\n     * @return          bytes29 - The memory view\\n     */\\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _len = arr.length;\\n\\n        uint256 _loc;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\\n        }\\n\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Return the associated type information.\\n     * @param memView   The memory view\\n     * @return          _type - The type associated with the view\\n     */\\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 216 == 256 - 40\\n            _type := shr(216, memView) // shift out lower 24 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the 5-byte type flag is equal\\n     */\\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n    }\\n\\n    /**\\n     * @notice          Return the memory address of the underlying bytes.\\n     * @param memView   The view\\n     * @return          _loc - The memory address\\n     */\\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n            _loc := and(shr(120, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          The number of memory words this memory view occupies, rounded up.\\n     * @param memView   The view\\n     * @return          uint256 - The number of memory words\\n     */\\n    function words(bytes29 memView) internal pure returns (uint256) {\\n        return uint256(len(memView)).add(32) / 32;\\n    }\\n\\n    /**\\n     * @notice          The in-memory footprint of a fresh copy of the view.\\n     * @param memView   The view\\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n     */\\n    function footprint(bytes29 memView) internal pure returns (uint256) {\\n        return words(memView) * 32;\\n    }\\n\\n    /**\\n     * @notice          The number of bytes of the view.\\n     * @param memView   The view\\n     * @return          _len - The length of the view\\n     */\\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _len := and(shr(24, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Returns the endpoint of `memView`.\\n     * @param memView   The view\\n     * @return          uint256 - The endpoint of `memView`\\n     */\\n    function end(bytes29 memView) internal pure returns (uint256) {\\n        return loc(memView) + len(memView);\\n    }\\n\\n    /**\\n     * @notice          Safe slicing without memory modification.\\n     * @param memView   The view\\n     * @param _index    The start index\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _loc = loc(memView);\\n\\n        // Ensure it doesn't overrun the view\\n        if (_loc.add(_index).add(_len) > end(memView)) {\\n            return NULL;\\n        }\\n\\n        _loc = _loc.add(_index);\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, 0, _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Construct an error message for an indexing overrun.\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @param _index    The index\\n     * @param _slice    The slice where the overrun occurred\\n     * @return          err - The err\\n     */\\n    function indexErrOverrun(\\n        uint256 _loc,\\n        uint256 _len,\\n        uint256 _index,\\n        uint256 _slice\\n    ) internal pure returns (string memory err) {\\n        (, uint256 a) = encodeHex(_loc);\\n        (, uint256 b) = encodeHex(_len);\\n        (, uint256 c) = encodeHex(_index);\\n        (, uint256 d) = encodeHex(_slice);\\n        err = string(\\n            abi.encodePacked(\\n                \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n                uint48(a),\\n                \\\" with length 0x\\\",\\n                uint48(b),\\n                \\\". Attempted to index at offset 0x\\\",\\n                uint48(c),\\n                \\\" with length 0x\\\",\\n                uint48(d),\\n                \\\".\\\"\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice          Load up to 32 bytes from the view onto the stack.\\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n     *                  This can be immediately cast to a smaller fixed-length byte array.\\n     *                  To automatically cast to an integer, use `indexUint`.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The 32 byte result\\n     */\\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {\\n        if (_bytes == 0) {return bytes32(0);}\\n        if (_index.add(_bytes) > len(memView)) {\\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n        }\\n        require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n        uint8 bitLength = _bytes * 8;\\n        uint256 _loc = loc(memView);\\n        uint256 _mask = leftMask(bitLength);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            result := and(mload(add(_loc, _index)), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from the view at `_index`.\\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from LE bytes.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\\n    }\\n\\n    /**\\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n     *                  following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @return          address - The address\\n     */\\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n        return address(uint160(indexUint(memView, _index, 20)));\\n    }\\n\\n    /**\\n     * @notice          Return the keccak256 hash of the underlying memory\\n     * @param memView   The view\\n     * @return          digest - The keccak256 hash of the underlying memory\\n     */\\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            digest := keccak256(_loc, _len)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return the sha2 digest of the underlying memory.\\n     * @dev             We explicitly deallocate memory afterwards.\\n     * @param memView   The view\\n     * @return          digest - The sha2 hash of the underlying memory\\n     */\\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n     * @param memView   The pre-image\\n     * @return          digest - the Digest\\n     */\\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash256 (double sha2)\\n     * @param memView   A view of the preimage\\n     * @return          digest - the Digest\\n     */\\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return true if the underlying memory is equal. Else false.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the underlying memory is equal\\n     */\\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n    }\\n\\n    /**\\n     * @notice          Return false if the underlying memory is equal. Else true.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - False if the underlying memory is equal\\n     */\\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !untypedEqual(left, right);\\n    }\\n\\n    /**\\n     * @notice          Compares type equality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are the same\\n     */\\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n    }\\n\\n    /**\\n     * @notice          Compares type inequality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are not the same\\n     */\\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !equal(left, right);\\n    }\\n\\n    /**\\n     * @notice          Copy the view to a location, return an unsafe memory reference\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memView   The view\\n     * @param _newLoc   The new location\\n     * @return          written - the unsafe memory reference\\n     */\\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n        require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n        require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n        uint256 _len = len(memView);\\n        uint256 _oldLoc = loc(memView);\\n\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _newLoc) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n\\n            // use the identity precompile to copy\\n            // guaranteed not to fail, so pop the success\\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n        }\\n\\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n    }\\n\\n    /**\\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n     *                  the new memory\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param memView   The view\\n     * @return          ret - The view pointing to the new memory\\n     */\\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n            ret := ptr\\n        }\\n        unsafeCopyTo(memView, ptr + 0x20);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n            mstore(ptr, _len) // write len of new array (in bytes)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memViews  The views\\n     * @return          unsafeView - The conjoined view pointing to the new memory\\n     */\\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _location) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n        }\\n\\n        uint256 _offset = 0;\\n        for (uint256 i = 0; i < memViews.length; i ++) {\\n            bytes29 memView = memViews[i];\\n            unsafeCopyTo(memView, _location + _offset);\\n            _offset += len(memView);\\n        }\\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n    }\\n\\n    /**\\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The keccak256 digest\\n     */\\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return keccak(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The sha256 digest\\n     */\\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return sha2(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          copies all views, joins them into a new bytearray.\\n     * @param memViews  The views\\n     * @return          ret - The new byte array\\n     */\\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n\\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\n        uint256 _written = len(_newView);\\n        uint256 _footprint = footprint(_newView);\\n\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // store the legnth\\n            mstore(ptr, _written)\\n            // new pointer is old + 0x20 + the footprint of the body\\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\\n            ret := ptr\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Encoding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\nlibrary Encoding {\\n    // ============ Constants ============\\n\\n    bytes private constant NIBBLE_LOOKUP = \\\"0123456789abcdef\\\";\\n\\n    // ============ Internal Functions ============\\n\\n    /**\\n     * @notice Encode a uint32 in its DECIMAL representation, with leading\\n     * zeroes.\\n     * @param _num The number to encode\\n     * @return _encoded The encoded number, suitable for use in abi.\\n     * encodePacked\\n     */\\n    function decimalUint32(uint32 _num)\\n        internal\\n        pure\\n        returns (uint80 _encoded)\\n    {\\n        uint80 ASCII_0 = 0x30;\\n        // all over/underflows are impossible\\n        // this will ALWAYS produce 10 decimal characters\\n        for (uint8 i = 0; i < 10; i += 1) {\\n            _encoded |= ((_num % 10) + ASCII_0) << (i * 8);\\n            _num = _num / 10;\\n        }\\n    }\\n\\n    /**\\n     * @notice Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n     * `second` contains the encoded lower 16 bytes.\\n     * @param _bytes The 32 bytes as uint256\\n     * @return _firstHalf The top 16 bytes\\n     * @return _secondHalf The bottom 16 bytes\\n     */\\n    function encodeHex(uint256 _bytes)\\n        internal\\n        pure\\n        returns (uint256 _firstHalf, uint256 _secondHalf)\\n    {\\n        for (uint8 i = 31; i > 15; i -= 1) {\\n            uint8 _b = uint8(_bytes >> (i * 8));\\n            _firstHalf |= _byteHex(_b);\\n            if (i != 16) {\\n                _firstHalf <<= 16;\\n            }\\n        }\\n        // abusing underflow here =_=\\n        for (uint8 i = 15; i < 255; i -= 1) {\\n            uint8 _b = uint8(_bytes >> (i * 8));\\n            _secondHalf |= _byteHex(_b);\\n            if (i != 0) {\\n                _secondHalf <<= 16;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\\n     * @param _byte The byte\\n     * @return _char The encoded hex character\\n     */\\n    function _nibbleHex(uint8 _byte) private pure returns (uint8 _char) {\\n        uint8 _nibble = _byte & 0x0f; // keep bottom 4, 0 top 4\\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\\n    }\\n\\n    /**\\n     * @notice Returns a uint16 containing the hex-encoded byte.\\n     * @param _byte The byte\\n     * @return _encoded The hex-encoded byte\\n     */\\n    function _byteHex(uint8 _byte) private pure returns (uint16 _encoded) {\\n        _encoded |= _nibbleHex(_byte >> 4); // top 4 bits\\n        _encoded <<= 8;\\n        _encoded |= _nibbleHex(_byte); // lower 4 bits\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/upgrade/UpgradeBeaconProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.11;\\n\\n// ============ External Imports ============\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title UpgradeBeaconProxy\\n * @notice\\n * Proxy contract which delegates all logic, including initialization,\\n * to an implementation contract.\\n * The implementation contract is stored within an Upgrade Beacon contract;\\n * the implementation contract can be changed by performing an upgrade on the Upgrade Beacon contract.\\n * The Upgrade Beacon contract for this Proxy is immutably specified at deployment.\\n * @dev This implementation combines the gas savings of keeping the UpgradeBeacon address outside of contract storage\\n * found in 0age's implementation:\\n * https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/proxies/smart-wallet/UpgradeBeaconProxyV1.sol\\n * With the added safety checks that the UpgradeBeacon and implementation are contracts at time of deployment\\n * found in OpenZeppelin's implementation:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol\\n */\\ncontract UpgradeBeaconProxy {\\n    // ============ Immutables ============\\n\\n    // Upgrade Beacon address is immutable (therefore not kept in contract storage)\\n    address private immutable upgradeBeacon;\\n\\n    // ============ Constructor ============\\n\\n    /**\\n     * @notice Validate that the Upgrade Beacon is a contract, then set its\\n     * address immutably within this contract.\\n     * Validate that the implementation is also a contract,\\n     * Then call the initialization function defined at the implementation.\\n     * The deployment will revert and pass along the\\n     * revert reason if the initialization function reverts.\\n     * @param _upgradeBeacon Address of the Upgrade Beacon to be stored immutably in the contract\\n     * @param _initializationCalldata Calldata supplied when calling the initialization function\\n     */\\n    constructor(address _upgradeBeacon, bytes memory _initializationCalldata)\\n        payable\\n    {\\n        // Validate the Upgrade Beacon is a contract\\n        require(Address.isContract(_upgradeBeacon), \\\"beacon !contract\\\");\\n        // set the Upgrade Beacon\\n        upgradeBeacon = _upgradeBeacon;\\n        // Validate the implementation is a contract\\n        address _implementation = _getImplementation(_upgradeBeacon);\\n        require(\\n            Address.isContract(_implementation),\\n            \\\"beacon implementation !contract\\\"\\n        );\\n        // Call the initialization function on the implementation\\n        if (_initializationCalldata.length > 0) {\\n            _initialize(_implementation, _initializationCalldata);\\n        }\\n    }\\n\\n    // ============ External Functions ============\\n\\n    /**\\n     * @notice Forwards all calls with data to _fallback()\\n     * No public functions are declared on the contract, so all calls hit fallback\\n     */\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @notice Forwards all calls with no data to _fallback()\\n     */\\n    receive() external payable {\\n        _fallback();\\n    }\\n\\n    // ============ Private Functions ============\\n\\n    /**\\n     * @notice Call the initialization function on the implementation\\n     * Used at deployment to initialize the proxy\\n     * based on the logic for initialization defined at the implementation\\n     * @param _implementation - Contract to which the initalization is delegated\\n     * @param _initializationCalldata - Calldata supplied when calling the initialization function\\n     */\\n    function _initialize(\\n        address _implementation,\\n        bytes memory _initializationCalldata\\n    ) private {\\n        // Delegatecall into the implementation, supplying initialization calldata.\\n        (bool _ok, ) = _implementation.delegatecall(_initializationCalldata);\\n        // Revert and include revert data if delegatecall to implementation reverts.\\n        if (!_ok) {\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Delegates function calls to the implementation contract returned by the Upgrade Beacon\\n     */\\n    function _fallback() private {\\n        _delegate(_getImplementation());\\n    }\\n\\n    /**\\n     * @notice Delegate function execution to the implementation contract\\n     * @dev This is a low level function that doesn't return to its internal\\n     * call site. It will return whatever is returned by the implementation to the\\n     * external caller, reverting and returning the revert data if implementation\\n     * reverts.\\n     * @param _implementation - Address to which the function execution is delegated\\n     */\\n    function _delegate(address _implementation) private {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n            // Delegatecall to the implementation, supplying calldata and gas.\\n            // Out and outsize are set to zero - instead, use the return buffer.\\n            let result := delegatecall(\\n                gas(),\\n                _implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            // Copy the returned data from the return buffer.\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            // Delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Call the Upgrade Beacon to get the current implementation contract address\\n     * @return _implementation Address of the current implementation.\\n     */\\n    function _getImplementation()\\n        private\\n        view\\n        returns (address _implementation)\\n    {\\n        _implementation = _getImplementation(upgradeBeacon);\\n    }\\n\\n    /**\\n     * @notice Call the Upgrade Beacon to get the current implementation contract address\\n     * @dev _upgradeBeacon is passed as a parameter so that\\n     * we can also use this function in the constructor,\\n     * where we can't access immutable variables.\\n     * @param _upgradeBeacon Address of the UpgradeBeacon storing the current implementation\\n     * @return _implementation Address of the current implementation.\\n     */\\n    function _getImplementation(address _upgradeBeacon)\\n        private\\n        view\\n        returns (address _implementation)\\n    {\\n        // Get the current implementation address from the upgrade beacon.\\n        (bool _ok, bytes memory _returnData) = _upgradeBeacon.staticcall(\\\"\\\");\\n        // Revert and pass along revert message if call to upgrade beacon reverts.\\n        require(_ok, string(_returnData));\\n        // Set the implementation to the address returned from the upgrade beacon.\\n        _implementation = abi.decode(_returnData, (address));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@summa-tx/memview-sol/contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.10;\\n\\n/*\\nThe MIT License (MIT)\\n\\nCopyright (c) 2016 Smart Contract Solutions, Inc.\\n\\nPermission is hereby granted, free of charge, to any person obtaining\\na copy of this software and associated documentation files (the\\n\\\"Software\\\"), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to\\npermit persons to whom the Software is furnished to do so, subject to\\nthe following conditions:\\n\\nThe above copyright notice and this permission notice shall be included\\nin all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n     * @dev Multiplies two numbers, throws on overflow.\\n     */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        c = _a * _b;\\n        require(c / _a == _b, \\\"Overflow during multiplication.\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two numbers, truncating the quotient.\\n     */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // assert(_b > 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n        return _a / _b;\\n    }\\n\\n    /**\\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b <= _a, \\\"Underflow during subtraction.\\\");\\n        return _a - _b;\\n    }\\n\\n    /**\\n     * @dev Adds two numbers, throws on overflow.\\n     */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n        c = _a + _b;\\n        require(c >= _a, \\\"Overflow during addition.\\\");\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/Common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {Message} from \\\"../libs/Message.sol\\\";\\n// ============ External Imports ============\\nimport {ECDSA} from \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\n/**\\n * @title Common\\n * @author Celo Labs Inc.\\n * @notice Shared utilities between Home and Replica.\\n */\\nabstract contract Common is Initializable {\\n    // ============ Enums ============\\n\\n    // States:\\n    //   0 - UnInitialized - before initialize function is called\\n    //   note: the contract is initialized at deploy time, so it should never be in this state\\n    //   1 - Active - as long as the contract has not become fraudulent\\n    //   2 - Failed - after a valid fraud proof has been submitted;\\n    //   contract will no longer accept updates or new messages\\n    enum States {\\n        UnInitialized,\\n        Active,\\n        Failed\\n    }\\n\\n    // ============ Immutable Variables ============\\n\\n    // Domain of chain on which the contract is deployed\\n    uint32 public immutable localDomain;\\n\\n    // ============ Public Variables ============\\n\\n    // Address of bonded Updater\\n    address public updater;\\n    // Current state of contract\\n    States public state;\\n    // The latest root that has been signed by the Updater\\n    bytes32 public committedRoot;\\n\\n    // ============ Upgrade Gap ============\\n\\n    // gap for upgrade safety\\n    uint256[47] private __GAP;\\n\\n    // ============ Events ============\\n\\n    /**\\n     * @notice Emitted when update is made on Home\\n     * or unconfirmed update root is submitted on Replica\\n     * @param homeDomain Domain of home contract\\n     * @param oldRoot Old merkle root\\n     * @param newRoot New merkle root\\n     * @param signature Updater's signature on `oldRoot` and `newRoot`\\n     */\\n    event Update(\\n        uint32 indexed homeDomain,\\n        bytes32 indexed oldRoot,\\n        bytes32 indexed newRoot,\\n        bytes signature\\n    );\\n\\n    /**\\n     * @notice Emitted when proof of a double update is submitted,\\n     * which sets the contract to FAILED state\\n     * @param oldRoot Old root shared between two conflicting updates\\n     * @param newRoot Array containing two conflicting new roots\\n     * @param signature Signature on `oldRoot` and `newRoot`[0]\\n     * @param signature2 Signature on `oldRoot` and `newRoot`[1]\\n     */\\n    event DoubleUpdate(\\n        bytes32 oldRoot,\\n        bytes32[2] newRoot,\\n        bytes signature,\\n        bytes signature2\\n    );\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @notice Ensures that contract state != FAILED when the function is called\\n     */\\n    modifier notFailed() {\\n        require(state != States.Failed, \\\"failed state\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(uint32 _localDomain) {\\n        localDomain = _localDomain;\\n    }\\n\\n    // ============ Initializer ============\\n\\n    function __Common_initialize(address _updater) internal initializer {\\n        updater = _updater;\\n        state = States.Active;\\n    }\\n\\n    // ============ External Functions ============\\n\\n    /**\\n     * @notice Called by external agent. Checks that signatures on two sets of\\n     * roots are valid and that the new roots conflict with each other. If both\\n     * cases hold true, the contract is failed and a `DoubleUpdate` event is\\n     * emitted.\\n     * @dev When `fail()` is called on Home, updater is slashed.\\n     * @param _oldRoot Old root shared between two conflicting updates\\n     * @param _newRoot Array containing two conflicting new roots\\n     * @param _signature Signature on `_oldRoot` and `_newRoot`[0]\\n     * @param _signature2 Signature on `_oldRoot` and `_newRoot`[1]\\n     */\\n    function doubleUpdate(\\n        bytes32 _oldRoot,\\n        bytes32[2] calldata _newRoot,\\n        bytes calldata _signature,\\n        bytes calldata _signature2\\n    ) external notFailed {\\n        if (\\n            Common._isUpdaterSignature(_oldRoot, _newRoot[0], _signature) &&\\n            Common._isUpdaterSignature(_oldRoot, _newRoot[1], _signature2) &&\\n            _newRoot[0] != _newRoot[1]\\n        ) {\\n            _fail();\\n            emit DoubleUpdate(_oldRoot, _newRoot, _signature, _signature2);\\n        }\\n    }\\n\\n    // ============ Public Functions ============\\n\\n    /**\\n     * @notice Hash of Home domain concatenated with \\\"OPTICS\\\"\\n     */\\n    function homeDomainHash() public view virtual returns (bytes32);\\n\\n    // ============ Internal Functions ============\\n\\n    /**\\n     * @notice Hash of Home domain concatenated with \\\"OPTICS\\\"\\n     * @param _homeDomain the Home domain to hash\\n     */\\n    function _homeDomainHash(uint32 _homeDomain)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(_homeDomain, \\\"OPTICS\\\"));\\n    }\\n\\n    /**\\n     * @notice Set contract state to FAILED\\n     * @dev Called when a valid fraud proof is submitted\\n     */\\n    function _setFailed() internal {\\n        state = States.Failed;\\n    }\\n\\n    /**\\n     * @notice Moves the contract into failed state\\n     * @dev Called when fraud is proven\\n     * (Double Update is submitted on Home or Replica,\\n     * or Improper Update is submitted on Home)\\n     */\\n    function _fail() internal virtual;\\n\\n    /**\\n     * @notice Checks that signature was signed by Updater\\n     * @param _oldRoot Old merkle root\\n     * @param _newRoot New merkle root\\n     * @param _signature Signature on `_oldRoot` and `_newRoot`\\n     * @return TRUE iff signature is valid signed by updater\\n     **/\\n    function _isUpdaterSignature(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return (ECDSA.recover(_digest, _signature) == updater);\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/libs/Queue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n/**\\n * @title QueueLib\\n * @author Celo Labs Inc.\\n * @notice Library containing queue struct and operations for queue used by\\n * Home and Replica.\\n **/\\nlibrary QueueLib {\\n    /**\\n     * @notice Queue struct\\n     * @dev Internally keeps track of the `first` and `last` elements through\\n     * indices and a mapping of indices to enqueued elements.\\n     **/\\n    struct Queue {\\n        uint128 first;\\n        uint128 last;\\n        mapping(uint256 => bytes32) queue;\\n    }\\n\\n    /**\\n     * @notice Initializes the queue\\n     * @dev Empty state denoted by _q.first > q._last. Queue initialized\\n     * with _q.first = 1 and _q.last = 0.\\n     **/\\n    function initialize(Queue storage _q) internal {\\n        if (_q.first == 0) {\\n            _q.first = 1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Enqueues a single new element\\n     * @param _item New element to be enqueued\\n     * @return _last Index of newly enqueued element\\n     **/\\n    function enqueue(Queue storage _q, bytes32 _item)\\n        internal\\n        returns (uint128 _last)\\n    {\\n        _last = _q.last + 1;\\n        _q.last = _last;\\n        if (_item != bytes32(0)) {\\n            // saves gas if we're queueing 0\\n            _q.queue[_last] = _item;\\n        }\\n    }\\n\\n    /**\\n     * @notice Dequeues element at front of queue\\n     * @dev Removes dequeued element from storage\\n     * @return _item Dequeued element\\n     **/\\n    function dequeue(Queue storage _q) internal returns (bytes32 _item) {\\n        uint128 _last = _q.last;\\n        uint128 _first = _q.first;\\n        require(_length(_last, _first) != 0, \\\"Empty\\\");\\n        _item = _q.queue[_first];\\n        if (_item != bytes32(0)) {\\n            // saves gas if we're dequeuing 0\\n            delete _q.queue[_first];\\n        }\\n        _q.first = _first + 1;\\n    }\\n\\n    /**\\n     * @notice Batch enqueues several elements\\n     * @param _items Array of elements to be enqueued\\n     * @return _last Index of last enqueued element\\n     **/\\n    function enqueue(Queue storage _q, bytes32[] memory _items)\\n        internal\\n        returns (uint128 _last)\\n    {\\n        _last = _q.last;\\n        for (uint256 i = 0; i < _items.length; i += 1) {\\n            _last += 1;\\n            bytes32 _item = _items[i];\\n            if (_item != bytes32(0)) {\\n                _q.queue[_last] = _item;\\n            }\\n        }\\n        _q.last = _last;\\n    }\\n\\n    /**\\n     * @notice Batch dequeues `_number` elements\\n     * @dev Reverts if `_number` > queue length\\n     * @param _number Number of elements to dequeue\\n     * @return Array of dequeued elements\\n     **/\\n    function dequeue(Queue storage _q, uint256 _number)\\n        internal\\n        returns (bytes32[] memory)\\n    {\\n        uint128 _last = _q.last;\\n        uint128 _first = _q.first;\\n        // Cannot underflow unless state is corrupted\\n        require(_length(_last, _first) >= _number, \\\"Insufficient\\\");\\n\\n        bytes32[] memory _items = new bytes32[](_number);\\n\\n        for (uint256 i = 0; i < _number; i++) {\\n            _items[i] = _q.queue[_first];\\n            delete _q.queue[_first];\\n            _first++;\\n        }\\n        _q.first = _first;\\n        return _items;\\n    }\\n\\n    /**\\n     * @notice Returns true if `_item` is in the queue and false if otherwise\\n     * @dev Linearly scans from _q.first to _q.last looking for `_item`\\n     * @param _item Item being searched for in queue\\n     * @return True if `_item` currently exists in queue, false if otherwise\\n     **/\\n    function contains(Queue storage _q, bytes32 _item)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        for (uint256 i = _q.first; i <= _q.last; i++) {\\n            if (_q.queue[i] == _item) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @notice Returns last item in queue\\n    /// @dev Returns bytes32(0) if queue empty\\n    function lastItem(Queue storage _q) internal view returns (bytes32) {\\n        return _q.queue[_q.last];\\n    }\\n\\n    /// @notice Returns element at front of queue without removing element\\n    /// @dev Reverts if queue is empty\\n    function peek(Queue storage _q) internal view returns (bytes32 _item) {\\n        require(!isEmpty(_q), \\\"Empty\\\");\\n        _item = _q.queue[_q.first];\\n    }\\n\\n    /// @notice Returns true if queue is empty and false if otherwise\\n    function isEmpty(Queue storage _q) internal view returns (bool) {\\n        return _q.last < _q.first;\\n    }\\n\\n    /// @notice Returns number of elements in queue\\n    function length(Queue storage _q) internal view returns (uint256) {\\n        uint128 _last = _q.last;\\n        uint128 _first = _q.first;\\n        // Cannot underflow unless state is corrupted\\n        return _length(_last, _first);\\n    }\\n\\n    /// @notice Returns number of elements between `_last` and `_first` (used internally)\\n    function _length(uint128 _last, uint128 _first)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return uint256(_last + 1 - _first);\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/libs/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// work based on eth2 deposit contract, which is used under CC0-1.0\\n\\n/**\\n * @title MerkleLib\\n * @author Celo Labs Inc.\\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\\n **/\\nlibrary MerkleLib {\\n    uint256 internal constant TREE_DEPTH = 32;\\n    uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\\n\\n    /**\\n     * @notice Struct representing incremental merkle tree. Contains current\\n     * branch and the number of inserted leaves in the tree.\\n     **/\\n    struct Tree {\\n        bytes32[TREE_DEPTH] branch;\\n        uint256 count;\\n    }\\n\\n    /**\\n     * @notice Inserts `_node` into merkle tree\\n     * @dev Reverts if tree is full\\n     * @param _node Element to insert into tree\\n     **/\\n    function insert(Tree storage _tree, bytes32 _node) internal {\\n        require(_tree.count < MAX_LEAVES, \\\"merkle tree full\\\");\\n\\n        _tree.count += 1;\\n        uint256 size = _tree.count;\\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\\n            if ((size & 1) == 1) {\\n                _tree.branch[i] = _node;\\n                return;\\n            }\\n            _node = keccak256(abi.encodePacked(_tree.branch[i], _node));\\n            size /= 2;\\n        }\\n        // As the loop should always end prematurely with the `return` statement,\\n        // this code should be unreachable. We assert `false` just to be safe.\\n        assert(false);\\n    }\\n\\n    /**\\n     * @notice Calculates and returns`_tree`'s current root given array of zero\\n     * hashes\\n     * @param _zeroes Array of zero hashes\\n     * @return _current Calculated root of `_tree`\\n     **/\\n    function rootWithCtx(Tree storage _tree, bytes32[TREE_DEPTH] memory _zeroes)\\n        internal\\n        view\\n        returns (bytes32 _current)\\n    {\\n        uint256 _index = _tree.count;\\n\\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\\n            uint256 _ithBit = (_index >> i) & 0x01;\\n            bytes32 _next = _tree.branch[i];\\n            if (_ithBit == 1) {\\n                _current = keccak256(abi.encodePacked(_next, _current));\\n            } else {\\n                _current = keccak256(abi.encodePacked(_current, _zeroes[i]));\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates and returns`_tree`'s current root\\n    function root(Tree storage _tree) internal view returns (bytes32) {\\n        return rootWithCtx(_tree, zeroHashes());\\n    }\\n\\n    /// @notice Returns array of TREE_DEPTH zero hashes\\n    /// @return _zeroes Array of TREE_DEPTH zero hashes\\n    function zeroHashes()\\n        internal\\n        pure\\n        returns (bytes32[TREE_DEPTH] memory _zeroes)\\n    {\\n        _zeroes[0] = Z_0;\\n        _zeroes[1] = Z_1;\\n        _zeroes[2] = Z_2;\\n        _zeroes[3] = Z_3;\\n        _zeroes[4] = Z_4;\\n        _zeroes[5] = Z_5;\\n        _zeroes[6] = Z_6;\\n        _zeroes[7] = Z_7;\\n        _zeroes[8] = Z_8;\\n        _zeroes[9] = Z_9;\\n        _zeroes[10] = Z_10;\\n        _zeroes[11] = Z_11;\\n        _zeroes[12] = Z_12;\\n        _zeroes[13] = Z_13;\\n        _zeroes[14] = Z_14;\\n        _zeroes[15] = Z_15;\\n        _zeroes[16] = Z_16;\\n        _zeroes[17] = Z_17;\\n        _zeroes[18] = Z_18;\\n        _zeroes[19] = Z_19;\\n        _zeroes[20] = Z_20;\\n        _zeroes[21] = Z_21;\\n        _zeroes[22] = Z_22;\\n        _zeroes[23] = Z_23;\\n        _zeroes[24] = Z_24;\\n        _zeroes[25] = Z_25;\\n        _zeroes[26] = Z_26;\\n        _zeroes[27] = Z_27;\\n        _zeroes[28] = Z_28;\\n        _zeroes[29] = Z_29;\\n        _zeroes[30] = Z_30;\\n        _zeroes[31] = Z_31;\\n    }\\n\\n    /**\\n     * @notice Calculates and returns the merkle root for the given leaf\\n     * `_item`, a merkle branch, and the index of `_item` in the tree.\\n     * @param _item Merkle leaf\\n     * @param _branch Merkle proof\\n     * @param _index Index of `_item` in tree\\n     * @return _current Calculated merkle root\\n     **/\\n    function branchRoot(\\n        bytes32 _item,\\n        bytes32[TREE_DEPTH] memory _branch,\\n        uint256 _index\\n    ) internal pure returns (bytes32 _current) {\\n        _current = _item;\\n\\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\\n            uint256 _ithBit = (_index >> i) & 0x01;\\n            bytes32 _next = _branch[i];\\n            if (_ithBit == 1) {\\n                _current = keccak256(abi.encodePacked(_next, _current));\\n            } else {\\n                _current = keccak256(abi.encodePacked(_current, _next));\\n            }\\n        }\\n    }\\n\\n    // keccak256 zero hashes\\n    bytes32 internal constant Z_0 =\\n        hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\";\\n    bytes32 internal constant Z_1 =\\n        hex\\\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\\\";\\n    bytes32 internal constant Z_2 =\\n        hex\\\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\\\";\\n    bytes32 internal constant Z_3 =\\n        hex\\\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\\\";\\n    bytes32 internal constant Z_4 =\\n        hex\\\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\\\";\\n    bytes32 internal constant Z_5 =\\n        hex\\\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\\\";\\n    bytes32 internal constant Z_6 =\\n        hex\\\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\\\";\\n    bytes32 internal constant Z_7 =\\n        hex\\\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\\\";\\n    bytes32 internal constant Z_8 =\\n        hex\\\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\\\";\\n    bytes32 internal constant Z_9 =\\n        hex\\\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\\\";\\n    bytes32 internal constant Z_10 =\\n        hex\\\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\\\";\\n    bytes32 internal constant Z_11 =\\n        hex\\\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\\\";\\n    bytes32 internal constant Z_12 =\\n        hex\\\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\\\";\\n    bytes32 internal constant Z_13 =\\n        hex\\\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\\\";\\n    bytes32 internal constant Z_14 =\\n        hex\\\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\\\";\\n    bytes32 internal constant Z_15 =\\n        hex\\\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\\\";\\n    bytes32 internal constant Z_16 =\\n        hex\\\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\\\";\\n    bytes32 internal constant Z_17 =\\n        hex\\\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\\\";\\n    bytes32 internal constant Z_18 =\\n        hex\\\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\\\";\\n    bytes32 internal constant Z_19 =\\n        hex\\\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\\\";\\n    bytes32 internal constant Z_20 =\\n        hex\\\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\\\";\\n    bytes32 internal constant Z_21 =\\n        hex\\\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\\\";\\n    bytes32 internal constant Z_22 =\\n        hex\\\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\\\";\\n    bytes32 internal constant Z_23 =\\n        hex\\\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\\\";\\n    bytes32 internal constant Z_24 =\\n        hex\\\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\\\";\\n    bytes32 internal constant Z_25 =\\n        hex\\\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\\\";\\n    bytes32 internal constant Z_26 =\\n        hex\\\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\\\";\\n    bytes32 internal constant Z_27 =\\n        hex\\\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\\\";\\n    bytes32 internal constant Z_28 =\\n        hex\\\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\\\";\\n    bytes32 internal constant Z_29 =\\n        hex\\\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\\\";\\n    bytes32 internal constant Z_30 =\\n        hex\\\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\\\";\\n    bytes32 internal constant Z_31 =\\n        hex\\\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\\\";\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/libs/Message.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\nimport \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\n\\nimport {\\n    TypeCasts\\n} from \\\"./TypeCasts.sol\\\";\\n\\n/**\\n * @title Message Library\\n * @author Celo Labs Inc.\\n * @notice Library for formatted messages used by Home and Replica.\\n **/\\nlibrary Message {\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n\\n    // Number of bytes in formatted message before `body` field\\n    uint256 internal constant PREFIX_LENGTH = 76;\\n\\n    /**\\n     * @notice Returns formatted (packed) message with provided fields\\n     * @param _originDomain Domain of home chain\\n     * @param _sender Address of sender as bytes32\\n     * @param _nonce Destination-specific nonce\\n     * @param _destinationDomain Domain of destination chain\\n     * @param _recipient Address of recipient on destination chain as bytes32\\n     * @param _messageBody Raw bytes of message body\\n     * @return Formatted message\\n     **/\\n    function formatMessage(\\n        uint32 _originDomain,\\n        bytes32 _sender,\\n        uint32 _nonce,\\n        uint32 _destinationDomain,\\n        bytes32 _recipient,\\n        bytes memory _messageBody\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _originDomain,\\n                _sender,\\n                _nonce,\\n                _destinationDomain,\\n                _recipient,\\n                _messageBody\\n            );\\n    }\\n\\n    /**\\n     * @notice Returns leaf of formatted message with provided fields.\\n     * @param _origin Domain of home chain\\n     * @param _sender Address of sender as bytes32\\n     * @param _nonce Destination-specific nonce number\\n     * @param _destination Domain of destination chain\\n     * @param _recipient Address of recipient on destination chain as bytes32\\n     * @param _body Raw bytes of message body\\n     * @return Leaf (hash) of formatted message\\n     **/\\n    function messageHash(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        uint32 _nonce,\\n        uint32 _destination,\\n        bytes32 _recipient,\\n        bytes memory _body\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                formatMessage(\\n                    _origin,\\n                    _sender,\\n                    _nonce,\\n                    _destination,\\n                    _recipient,\\n                    _body\\n                )\\n            );\\n    }\\n\\n    /// @notice Returns message's origin field\\n    function origin(bytes29 _message) internal pure returns (uint32) {\\n        return uint32(_message.indexUint(0, 4));\\n    }\\n\\n    /// @notice Returns message's sender field\\n    function sender(bytes29 _message) internal pure returns (bytes32) {\\n        return _message.index(4, 32);\\n    }\\n\\n    /// @notice Returns message's nonce field\\n    function nonce(bytes29 _message) internal pure returns (uint32) {\\n        return uint32(_message.indexUint(36, 4));\\n    }\\n\\n    /// @notice Returns message's destination field\\n    function destination(bytes29 _message) internal pure returns (uint32) {\\n        return uint32(_message.indexUint(40, 4));\\n    }\\n\\n    /// @notice Returns message's recipient field as bytes32\\n    function recipient(bytes29 _message) internal pure returns (bytes32) {\\n        return _message.index(44, 32);\\n    }\\n\\n    /// @notice Returns message's recipient field as an address\\n    function recipientAddress(bytes29 _message)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        return TypeCasts.bytes32ToAddress(recipient(_message));\\n    }\\n\\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\\n    function body(bytes29 _message) internal pure returns (bytes29) {\\n        return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\\n    }\\n\\n    function leaf(bytes29 _message) internal view returns (bytes32) {\\n        return messageHash(origin(_message), sender(_message), nonce(_message), destination(_message), recipient(_message), TypedMemView.clone(body(_message)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {MerkleLib} from \\\"../libs/Merkle.sol\\\";\\n\\n/**\\n * @title MerkleTreeManager\\n * @author Celo Labs Inc.\\n * @notice Contains a Merkle tree instance and\\n * exposes view functions for the tree.\\n */\\ncontract MerkleTreeManager {\\n    // ============ Libraries ============\\n\\n    using MerkleLib for MerkleLib.Tree;\\n    MerkleLib.Tree public tree;\\n\\n    // ============ Upgrade Gap ============\\n\\n    // gap for upgrade safety\\n    uint256[49] private __GAP;\\n\\n    // ============ Public Functions ============\\n\\n    /**\\n     * @notice Calculates and returns tree's current root\\n     */\\n    function root() public view returns (bytes32) {\\n        return tree.root();\\n    }\\n\\n    /**\\n     * @notice Returns the number of inserted leaves in the tree (current index)\\n     */\\n    function count() public view returns (uint256) {\\n        return tree.count;\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/Queue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {QueueLib} from \\\"../libs/Queue.sol\\\";\\n// ============ External Imports ============\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\n/**\\n * @title QueueManager\\n * @author Celo Labs Inc.\\n * @notice Contains a queue instance and\\n * exposes view functions for the queue.\\n **/\\ncontract QueueManager is Initializable {\\n    // ============ Libraries ============\\n\\n    using QueueLib for QueueLib.Queue;\\n    QueueLib.Queue internal queue;\\n\\n    // ============ Upgrade Gap ============\\n\\n    // gap for upgrade safety\\n    uint256[49] private __GAP;\\n\\n    // ============ Initializer ============\\n\\n    function __QueueManager_initialize() internal initializer {\\n        queue.initialize();\\n    }\\n\\n    // ============ Public Functions ============\\n\\n    /**\\n     * @notice Returns number of elements in queue\\n     */\\n    function queueLength() external view returns (uint256) {\\n        return queue.length();\\n    }\\n\\n    /**\\n     * @notice Returns TRUE iff `_item` is in the queue\\n     */\\n    function queueContains(bytes32 _item) external view returns (bool) {\\n        return queue.contains(_item);\\n    }\\n\\n    /**\\n     * @notice Returns last item enqueued to the queue\\n     */\\n    function queueEnd() external view returns (bytes32) {\\n        return queue.lastItem();\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/interfaces/IUpdaterManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\ninterface IUpdaterManager {\\n    function slashUpdater(address payable _reporter) external;\\n\\n    function updater() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/libs/TypeCasts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\nimport \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\n\\nlibrary TypeCasts {\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n\\n    function coerceBytes32(string memory _s)\\n        internal\\n        pure\\n        returns (bytes32 _b)\\n    {\\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\\n    }\\n\\n    // treat it as a null-terminated string of max 32 bytes\\n    function coerceString(bytes32 _buf)\\n        internal\\n        pure\\n        returns (string memory _newStr)\\n    {\\n        uint8 _slen = 0;\\n        while (_slen < 32 && _buf[_slen] != 0) {\\n            _slen++;\\n        }\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            _newStr := mload(0x40)\\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\\n            mstore(_newStr, _slen)\\n            mstore(add(_newStr, 0x20), _buf)\\n        }\\n    }\\n\\n    // alignment preserving cast\\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_addr)));\\n    }\\n\\n    // alignment preserving cast\\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\\n        return address(uint160(uint256(_buf)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/contracts/Replica.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n// ============ Internal Imports ============\\nimport {Version0} from \\\"./Version0.sol\\\";\\nimport {Common} from \\\"./Common.sol\\\";\\nimport {MerkleLib} from \\\"../libs/Merkle.sol\\\";\\nimport {Message} from \\\"../libs/Message.sol\\\";\\nimport {IMessageRecipient} from \\\"../interfaces/IMessageRecipient.sol\\\";\\n// ============ External Imports ============\\nimport {TypedMemView} from \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\n\\n/**\\n * @title Replica\\n * @author Celo Labs Inc.\\n * @notice Track root updates on Home,\\n * prove and dispatch messages to end recipients.\\n */\\ncontract Replica is Version0, Common {\\n    // ============ Libraries ============\\n\\n    using MerkleLib for MerkleLib.Tree;\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n    using Message for bytes29;\\n\\n    // ============ Enums ============\\n\\n    // Status of Message:\\n    //   0 - None - message has not been proven or processed\\n    //   1 - Proven - message inclusion proof has been validated\\n    //   2 - Processed - message has been dispatched to recipient\\n    enum MessageStatus {\\n        None,\\n        Proven,\\n        Processed\\n    }\\n\\n    // ============ Immutables ============\\n\\n    // Minimum gas for message processing\\n    uint256 public immutable PROCESS_GAS;\\n    // Reserved gas (to ensure tx completes in case message processing runs out)\\n    uint256 public immutable RESERVE_GAS;\\n\\n    // ============ Public Storage ============\\n\\n    // Domain of home chain\\n    uint32 public remoteDomain;\\n    // Number of seconds to wait before root becomes confirmable\\n    uint256 public optimisticSeconds;\\n    // re-entrancy guard\\n    uint8 private entered;\\n    // Mapping of roots to allowable confirmation times\\n    mapping(bytes32 => uint256) public confirmAt;\\n    // Mapping of message leaves to MessageStatus\\n    mapping(bytes32 => MessageStatus) public messages;\\n\\n    // ============ Upgrade Gap ============\\n\\n    // gap for upgrade safety\\n    uint256[44] private __GAP;\\n\\n    // ============ Events ============\\n\\n    /**\\n     * @notice Emitted when message is processed\\n     * @param messageHash Hash of message that failed to process\\n     * @param success TRUE if the call was executed successfully, FALSE if the call reverted\\n     * @param returnData the return data from the external call\\n     */\\n    event Process(\\n        bytes32 indexed messageHash,\\n        bool indexed success,\\n        bytes indexed returnData\\n    );\\n\\n    // ============ Constructor ============\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n        uint32 _localDomain,\\n        uint256 _processGas,\\n        uint256 _reserveGas\\n    ) Common(_localDomain) {\\n        require(_processGas >= 850_000, \\\"!process gas\\\");\\n        require(_reserveGas >= 15_000, \\\"!reserve gas\\\");\\n        PROCESS_GAS = _processGas;\\n        RESERVE_GAS = _reserveGas;\\n    }\\n\\n    // ============ Initializer ============\\n\\n    function initialize(\\n        uint32 _remoteDomain,\\n        address _updater,\\n        bytes32 _committedRoot,\\n        uint256 _optimisticSeconds\\n    ) public initializer {\\n        __Common_initialize(_updater);\\n        entered = 1;\\n        remoteDomain = _remoteDomain;\\n        committedRoot = _committedRoot;\\n        confirmAt[_committedRoot] = 1;\\n        optimisticSeconds = _optimisticSeconds;\\n    }\\n\\n    // ============ External Functions ============\\n\\n    /**\\n     * @notice Called by external agent. Submits the signed update's new root,\\n     * marks root's allowable confirmation time, and emits an `Update` event.\\n     * @dev Reverts if update doesn't build off latest committedRoot\\n     * or if signature is invalid.\\n     * @param _oldRoot Old merkle root\\n     * @param _newRoot New merkle root\\n     * @param _signature Updater's signature on `_oldRoot` and `_newRoot`\\n     */\\n    function update(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) external notFailed {\\n        // ensure that update is building off the last submitted root\\n        require(_oldRoot == committedRoot, \\\"not current update\\\");\\n        // validate updater signature\\n        require(\\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\\n            \\\"!updater sig\\\"\\n        );\\n        // Hook for future use\\n        _beforeUpdate();\\n        // set the new root's confirmation timer\\n        confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\\n        // update committedRoot\\n        committedRoot = _newRoot;\\n        emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\\n    }\\n\\n    /**\\n     * @notice First attempts to prove the validity of provided formatted\\n     * `message`. If the message is successfully proven, then tries to process\\n     * message.\\n     * @dev Reverts if `prove` call returns false\\n     * @param _message Formatted message (refer to Common.sol Message library)\\n     * @param _proof Merkle proof of inclusion for message's leaf\\n     * @param _index Index of leaf in home's merkle tree\\n     */\\n    function proveAndProcess(\\n        bytes memory _message,\\n        bytes32[32] calldata _proof,\\n        uint256 _index\\n    ) external {\\n        require(prove(keccak256(_message), _proof, _index), \\\"!prove\\\");\\n        process(_message);\\n    }\\n\\n    /**\\n     * @notice Given formatted message, attempts to dispatch\\n     * message payload to end recipient.\\n     * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)\\n     * Reverts if formatted message's destination domain is not the Replica's domain,\\n     * if message has not been proven,\\n     * or if not enough gas is provided for the dispatch transaction.\\n     * @param _message Formatted message\\n     * @return _success TRUE iff dispatch transaction succeeded\\n     */\\n    function process(bytes memory _message) public returns (bool _success) {\\n        bytes29 _m = _message.ref(0);\\n        // ensure message was meant for this domain\\n        require(_m.destination() == localDomain, \\\"!destination\\\");\\n        // ensure message has been proven\\n        bytes32 _messageHash = _m.keccak();\\n        require(messages[_messageHash] == MessageStatus.Proven, \\\"!proven\\\");\\n        // check re-entrancy guard\\n        require(entered == 1, \\\"!reentrant\\\");\\n        entered = 0;\\n        // update message status as processed\\n        messages[_messageHash] = MessageStatus.Processed;\\n        // A call running out of gas TYPICALLY errors the whole tx. We want to\\n        // a) ensure the call has a sufficient amount of gas to make a\\n        //    meaningful state change.\\n        // b) ensure that if the subcall runs out of gas, that the tx as a whole\\n        //    does not revert (i.e. we still mark the message processed)\\n        // To do this, we require that we have enough gas to process\\n        // and still return. We then delegate only the minimum processing gas.\\n        require(gasleft() >= PROCESS_GAS + RESERVE_GAS, \\\"!gas\\\");\\n        // get the message recipient\\n        address _recipient = _m.recipientAddress();\\n        // set up for assembly call\\n        uint256 _toCopy;\\n        uint256 _maxCopy = 256;\\n        uint256 _gas = PROCESS_GAS;\\n        // allocate memory for returndata\\n        bytes memory _returnData = new bytes(_maxCopy);\\n        bytes memory _calldata = abi.encodeWithSignature(\\n            \\\"handle(uint32,bytes32,bytes)\\\",\\n            _m.origin(),\\n            _m.sender(),\\n            _m.body().clone()\\n        );\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            _success := call(\\n                _gas, // gas\\n                _recipient, // recipient\\n                0, // ether value\\n                add(_calldata, 0x20), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n            // limit our copy to 256 bytes\\n            _toCopy := returndatasize()\\n            if gt(_toCopy, _maxCopy) {\\n                _toCopy := _maxCopy\\n            }\\n            // Store the length of the copied bytes\\n            mstore(_returnData, _toCopy)\\n            // copy the bytes from returndata[0:_toCopy]\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\n        }\\n        // emit process results\\n        emit Process(_messageHash, _success, _returnData);\\n        // reset re-entrancy guard\\n        entered = 1;\\n    }\\n\\n    // ============ Public Functions ============\\n\\n    /**\\n     * @notice Check that the root has been submitted\\n     * and that the optimistic timeout period has expired,\\n     * meaning the root can be processed\\n     * @param _root the Merkle root, submitted in an update, to check\\n     * @return TRUE iff root has been submitted & timeout has expired\\n     */\\n    function acceptableRoot(bytes32 _root) public view returns (bool) {\\n        uint256 _time = confirmAt[_root];\\n        if (_time == 0) {\\n            return false;\\n        }\\n        return block.timestamp >= _time;\\n    }\\n\\n    /**\\n     * @notice Attempts to prove the validity of message given its leaf, the\\n     * merkle proof of inclusion for the leaf, and the index of the leaf.\\n     * @dev Reverts if message's MessageStatus != None (i.e. if message was\\n     * already proven or processed)\\n     * @dev For convenience, we allow proving against any previous root.\\n     * This means that witnesses never need to be updated for the new root\\n     * @param _leaf Leaf of message to prove\\n     * @param _proof Merkle proof of inclusion for leaf\\n     * @param _index Index of leaf in home's merkle tree\\n     * @return Returns true if proof was valid and `prove` call succeeded\\n     **/\\n    function prove(\\n        bytes32 _leaf,\\n        bytes32[32] calldata _proof,\\n        uint256 _index\\n    ) public returns (bool) {\\n        // ensure that message has not been proven or processed\\n        require(messages[_leaf] == MessageStatus.None, \\\"!MessageStatus.None\\\");\\n        // calculate the expected root based on the proof\\n        bytes32 _calculatedRoot = MerkleLib.branchRoot(_leaf, _proof, _index);\\n        // if the root is valid, change status to Proven\\n        if (acceptableRoot(_calculatedRoot)) {\\n            messages[_leaf] = MessageStatus.Proven;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Hash of Home domain concatenated with \\\"OPTICS\\\"\\n     */\\n    function homeDomainHash() public view override returns (bytes32) {\\n        return _homeDomainHash(remoteDomain);\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    /**\\n     * @notice Moves the contract into failed state\\n     * @dev Called when a Double Update is submitted\\n     */\\n    function _fail() internal override {\\n        _setFailed();\\n    }\\n\\n    /// @notice Hook for potential future use\\n    // solhint-disable-next-line no-empty-blocks\\n    function _beforeUpdate() internal {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@celo-org/optics-sol/interfaces/IMessageRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\ninterface IMessageRecipient {\\n    function handle(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes memory _message\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "Uniswap", "timeStamp": "1668649583", "hash": "0xf52c3e5702a5cc83bd0312e415b55d280823f7686374de7c95db4215d87d6869", "contractAddress": "0x3ee18b2214aff97000d974cf647e7c347e8fa585", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/hhofstadt/Dev/certus/wormhole/ethereum/contracts/bridge/TokenBridge.sol\": {\r\n      \"content\": \"// contracts/Wormhole.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\n\\ncontract TokenBridge is ERC1967Proxy {\\n    constructor (address implementation, bytes memory initData)\\n    ERC1967Proxy(\\n        implementation,\\n        initData\\n    )\\n    {}\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            Address.functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\n                    \\\"upgradeTo(address)\\\",\\n                    oldImplementation\\n                )\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _setImplementation(newImplementation);\\n            emit Upgraded(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(\\n            Address.isContract(newBeacon),\\n            \\\"ERC1967: new beacon is not a contract\\\"\\n        );\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"}, {"protocol": "Uniswap", "timeStamp": "1668648983", "hash": "0xc0142a6c23c3678d0d8fef0e657d662ccbfa74df0088fbfdcb71aa4271c794c7", "contractAddress": "0x4dbd4fc535ac27206064b68ffcf827b0a60bab3f", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n     */\\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _admin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        require(newAdmin != address(0), \\\"TransparentUpgradeableProxy: new admin is the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n        Address.functionDelegateCall(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address adm) {\\n        bytes32 slot = _ADMIN_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        bytes32 slot = _ADMIN_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _admin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n *\\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if(_data.length > 0) {\\n            Address.functionDelegateCall(_logic, _data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal virtual {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableProxy: new implementation is not a contract\\\");\\n\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}"}, {"protocol": "Uniswap", "timeStamp": "1668648947", "hash": "0x0ee4d85f5d5c77d640f9a121689c9f943b9283562e4f465e190bfd44bd80562b", "contractAddress": "0xa0c68c638235ee32657e8f720a23cec1bfc77c77", "SourceCode": "// File: contracts/common/Proxy/IERCProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId);\r\n\r\n    function implementation() external view returns (address codeAddr);\r\n}\r\n\r\n// File: contracts/common/Proxy/Proxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract Proxy is IERCProxy {\r\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let result := delegatecall(\r\n                sub(gas(), 10000),\r\n                _dst,\r\n                add(_calldata, 0x20),\r\n                mload(_calldata),\r\n                0,\r\n                0\r\n            )\r\n            let size := returndatasize()\r\n\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n\r\n    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {\r\n        // Upgradeable proxy\r\n        proxyTypeId = 2;\r\n    }\r\n\r\n    function implementation() external virtual override view returns (address);\r\n}\r\n\r\n// File: contracts/common/Proxy/UpgradableProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract UpgradableProxy is Proxy {\r\n    event ProxyUpdated(address indexed _new, address indexed _old);\r\n    event ProxyOwnerUpdate(address _new, address _old);\r\n\r\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(\"matic.network.proxy.implementation\");\r\n    bytes32 constant OWNER_SLOT = keccak256(\"matic.network.proxy.owner\");\r\n\r\n    constructor(address _proxyTo) public {\r\n        setProxyOwner(msg.sender);\r\n        setImplementation(_proxyTo);\r\n    }\r\n\r\n    fallback() external payable {\r\n        delegatedFwd(loadImplementation(), msg.data);\r\n    }\r\n\r\n    receive() external payable {\r\n        delegatedFwd(loadImplementation(), msg.data);\r\n    }\r\n\r\n    modifier onlyProxyOwner() {\r\n        require(loadProxyOwner() == msg.sender, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    function proxyOwner() external view returns(address) {\r\n        return loadProxyOwner();\r\n    }\r\n\r\n    function loadProxyOwner() internal view returns(address) {\r\n        address _owner;\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            _owner := sload(position)\r\n        }\r\n        return _owner;\r\n    }\r\n\r\n    function implementation() external override view returns (address) {\r\n        return loadImplementation();\r\n    }\r\n\r\n    function loadImplementation() internal view returns(address) {\r\n        address _impl;\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            _impl := sload(position)\r\n        }\r\n        return _impl;\r\n    }\r\n\r\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());\r\n        setProxyOwner(newOwner);\r\n    }\r\n\r\n    function setProxyOwner(address newOwner) private {\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            sstore(position, newOwner)\r\n        }\r\n    }\r\n\r\n    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\r\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\r\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\r\n\r\n        emit ProxyUpdated(_newProxyTo, loadImplementation());\r\n        \r\n        setImplementation(_newProxyTo);\r\n    }\r\n\r\n    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\r\n        updateImplementation(_newProxyTo);\r\n\r\n        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    function setImplementation(address _newProxyTo) private {\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            sstore(position, _newProxyTo)\r\n        }\r\n    }\r\n    \r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_target)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/root/RootChainManager/RootChainManagerProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract RootChainManagerProxy is UpgradableProxy {\r\n    constructor(address _proxyTo)\r\n        public\r\n        UpgradableProxy(_proxyTo)\r\n    {}\r\n}"}, {"protocol": "Uniswap", "timeStamp": "1668648779", "hash": "0xc94ef9048d6802a0f71073e5c7afd2d8aadcd754d1d2189774503862f7707bc1", "contractAddress": "0x99c9fc46f92e8a1c0dec1b1747d010903e884be1", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/chugsplash/L1ChugSplashProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\nimport { iL1ChugSplashDeployer } from \\\"./interfaces/iL1ChugSplashDeployer.sol\\\";\\n\\n/**\\n * @title L1ChugSplashProxy\\n * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!\\n *\\n * Note for future developers: do NOT make anything in this contract 'public' unless you know what\\n * you're doing. Anything public can potentially have a function signature that conflicts with a\\n * signature attached to the implementation contract. Public functions SHOULD always have the\\n * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that\\n * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!\\n */\\ncontract L1ChugSplashProxy {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a contract, the\\n    // appended bytecode will be deployed as given.\\n    bytes13 constant internal DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 constant internal IMPLEMENTATION_KEY = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n    bytes32 constant internal OWNER_KEY = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n    \\n    /**\\n     * @param _owner Address of the initial contract owner.\\n     */\\n    constructor(\\n        address _owner\\n    ) {\\n        _setOwner(_owner);\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Blocks a function from being called when the parent signals that the system should be paused\\n     * via an isUpgrading function.\\n     */\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(\\n                iL1ChugSplashDeployer.isUpgrading.selector\\n            )\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(\\n                ret == 0,\\n                \\\"L1ChugSplashProxy: system is currently being upgraded\\\"\\n            );\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * Makes a proxy call instead of triggering the given function when the caller is either the\\n     * owner or the zero address. Caller can only ever be the zero address if this function is\\n     * being called off-chain via eth_call, which is totally fine and can be convenient for\\n     * client-side tooling. Avoids situations where the proxy and implementation share a sighash\\n     * and the proxy function ends up being called instead of the implementation one.\\n     *\\n     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a\\n     * way for someone to send a transaction with msg.sender == address(0) in any real context then\\n     * we have much bigger problems. Primary reason to include this additional allowed sender is\\n     * because the owner address can be changed dynamically and we do not want clients to have to\\n     * keep track of the current owner in order to make an eth_call that doesn't trigger the\\n     * proxied contract.\\n     */\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n\\n    /*********************\\n     * Fallback Function *\\n     *********************/\\n\\n    fallback()\\n        external\\n        payable\\n    {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the code that should be running behind this proxy. Note that this scheme is a bit\\n     * different from the standard proxy scheme where one would typically deploy the code\\n     * separately and then set the implementation address. We're doing it this way because it gives\\n     * us a lot more freedom on the client side. Can only be triggered by the contract owner.\\n     * @param _code New contract code to run inside this contract.\\n     */\\n    function setCode(\\n        bytes memory _code\\n    )\\n        proxyCallIfNotOwner\\n        public\\n    {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(\\n            DEPLOY_CODE_PREFIX,\\n            _code\\n        );\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed.\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /**\\n     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform\\n     * upgrades in a more transparent way. Only callable by the owner.\\n     * @param _key Storage key to modify.\\n     * @param _value New value for the storage key.\\n     */\\n    function setStorage(\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        proxyCallIfNotOwner\\n        public\\n    {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract. Only callable by the owner.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function setOwner(\\n        address _owner\\n    )\\n        proxyCallIfNotOwner\\n        public\\n    {\\n        _setOwner(_owner);\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Owner address.\\n     */\\n    function getOwner()\\n        proxyCallIfNotOwner\\n        public\\n        returns (\\n            address\\n        )\\n    {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * Queries the implementation address. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Implementation address.\\n     */\\n    function getImplementation()\\n        proxyCallIfNotOwner\\n        public\\n        returns (\\n            address\\n        )\\n    {\\n        return _getImplementation();\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Sets the implementation address.\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(\\n        address _implementation\\n    )\\n        internal\\n    {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /**\\n     * Queries the implementation address.\\n     * @return Implementation address.\\n     */\\n    function _getImplementation()\\n        internal\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function _setOwner(\\n        address _owner\\n    )\\n        internal\\n    {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract.\\n     * @return Owner address.\\n     */\\n    function _getOwner()\\n        internal\\n        view \\n        returns (\\n            address\\n        )\\n    {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * Gets the code hash for a given account.\\n     * @param _account Address of the account to get a code hash for.\\n     * @return Code hash for the account.\\n     */\\n    function _getAccountCodeHash(\\n        address _account\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n\\n    /**\\n     * Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall()\\n        onlyWhenNotPaused\\n        internal\\n    {\\n        address implementation = _getImplementation();\\n\\n        require(\\n            implementation != address(0),\\n            \\\"L1ChugSplashProxy: implementation is not set yet\\\"\\n        );\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n            \\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/chugsplash/interfaces/iL1ChugSplashDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iL1ChugSplashDeployer\\n */\\ninterface iL1ChugSplashDeployer {\\n    function isUpgrading()\\n        external\\n        view\\n        returns (\\n            bool\\n        );\\n}\\n\"\r\n    }\r\n  }\r\n}}"}, {"protocol": "Uniswap", "timeStamp": "1668647879", "hash": "0xf2f1fe96c16ee674bb7fcee166be52465a418927d124f5f1d231b36eae65d377", "contractAddress": "0x4e59b44847b379578588920ca78fbf26c0b4956c", "SourceCode": ""}, {"protocol": "Uniswap", "timeStamp": "1668647543", "hash": "0x74e7d57ad58c51912e3bd2a2b290d101219b20eebabed15097fe76e0c2bb390b", "contractAddress": "0xd32ff78579352ca78f416120a9f68b65c410871b", "SourceCode": ""}][{"protocol": "MakerDAO", "timeStamp": "1672860923", "hash": "0x7edfdf4a401c3c34346aa2e0b149fd8db6f1e4a120deb62d763ed7d00a7cff26", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1665614087", "hash": "0x1e08f3b161d3cf73a023ee2430df29653380b14354719a86fe6bb65c18d07a1b", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1664363459", "hash": "0xa4f96f65e9f4af4a7d71558572ecd3347b7dd1a0fffd75fba7d41aa4fbcabed5", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1663408667", "hash": "0x7c0ca0f50aae89fe546697034808e3efcbc3bbb7efe87807f0c208100539096b", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1654409772", "hash": "0x64bedfb669d43b55ba6208b8405a62de5d2ff911e850680e965591b3525a26b4", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1649733420", "hash": "0xe9206d4cb8d8946a402f218c41aa7e20406e1867a4bf760f55e18a39cb92afac", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1649358681", "hash": "0x0644acde1645d3d30a28d0160dae598b8231ec72887d2b2009ece7c53d706147", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1649357850", "hash": "0x90779a03b778d9bb6065eb4a87651adb48570dbadbcb116c2aeefc58f0940d4f", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1649356506", "hash": "0x02acf39936d56689632d75918179a819d7c9e6a7604bc8ceb055c0d80541aa96", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}, {"protocol": "MakerDAO", "timeStamp": "1648906793", "hash": "0x6f2da4b49db8f60c52d48af0f95057802d2e207dd605dda148638aa9be63b217", "contractAddress": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876", "SourceCode": ""}][{"protocol": "Optimism", "timeStamp": "1647550286", "hash": "0x85f37ea5eee568e4a514cbe2e034f0ef9c612981d3d55fcd20db602a44f22027", "contractAddress": "0x9996571372066a1545d3435c6935e3f9593a7ef5", "SourceCode": ""}, {"protocol": "Optimism", "timeStamp": "1647525713", "hash": "0x4133042ff75c93fba824503d3c5fc96338f17fce9fce560d111fc85e8a3d84fd", "contractAddress": "0x9996571372066a1545d3435c6935e3f9593a7ef5", "SourceCode": ""}, {"protocol": "Optimism", "timeStamp": "1636675748", "hash": "0xed2e696715675f37e1a5c17c6db8c67d3e41a2829bb79859afb4fdb07d29a588", "contractAddress": "0x25ace71c97b33cc4729cf772ae268934f7ab5fa1", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string indexed _name,\\n        address _newAddress,\\n        address _oldAddress\\n    );\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(\\n            _name,\\n            _address,\\n            oldAddress\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(\\n        string memory _name\\n    )\\n        external\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/resolver/Lib_ResolvedDelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_ResolvedDelegateProxy\\n */\\ncontract Lib_ResolvedDelegateProxy {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Using mappings to store fields to avoid overwriting storage slots in the\\n    // implementation contract. For example, instead of storing these fields at\\n    // storage slot `0` & `1`, they are stored at `keccak256(key + slot)`.\\n    // See: https://solidity.readthedocs.io/en/v0.7.0/internals/layout_in_storage.html\\n    // NOTE: Do not use this code in your own contract system.\\n    //      There is a known flaw in this contract, and we will remove it from the repository\\n    //      in the near future. Due to the very limited way that we are using it, this flaw is\\n    //      not an issue in our system.\\n    mapping (address => string) private implementationName;\\n    mapping (address => Lib_AddressManager) private addressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     * @param _implementationName implementationName of the contract to proxy to.\\n     */\\n    constructor(\\n        address _libAddressManager,\\n        string memory _implementationName\\n    ) {\\n        addressManager[address(this)] = Lib_AddressManager(_libAddressManager);\\n        implementationName[address(this)] = _implementationName;\\n    }\\n\\n\\n    /*********************\\n     * Fallback Function *\\n     *********************/\\n\\n    fallback()\\n        external\\n        payable\\n    {\\n        address target = addressManager[address(this)].getAddress(\\n            (implementationName[address(this)])\\n        );\\n\\n        require(\\n            target != address(0),\\n            \\\"Target address must be initialized.\\\"\\n        );\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\\n\\n        if (success == true) {\\n            assembly {\\n                return(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}"}, {"protocol": "Optimism", "timeStamp": "1633370599", "hash": "0x63ef79f88c205498a0b9e2d3301431dfe16cc21476079a4386268751bba750c4", "contractAddress": "0x99c9fc46f92e8a1c0dec1b1747d010903e884be1", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/chugsplash/L1ChugSplashProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\nimport { iL1ChugSplashDeployer } from \\\"./interfaces/iL1ChugSplashDeployer.sol\\\";\\n\\n/**\\n * @title L1ChugSplashProxy\\n * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!\\n *\\n * Note for future developers: do NOT make anything in this contract 'public' unless you know what\\n * you're doing. Anything public can potentially have a function signature that conflicts with a\\n * signature attached to the implementation contract. Public functions SHOULD always have the\\n * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that\\n * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!\\n */\\ncontract L1ChugSplashProxy {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a contract, the\\n    // appended bytecode will be deployed as given.\\n    bytes13 constant internal DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 constant internal IMPLEMENTATION_KEY = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n    bytes32 constant internal OWNER_KEY = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n    \\n    /**\\n     * @param _owner Address of the initial contract owner.\\n     */\\n    constructor(\\n        address _owner\\n    ) {\\n        _setOwner(_owner);\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Blocks a function from being called when the parent signals that the system should be paused\\n     * via an isUpgrading function.\\n     */\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(\\n                iL1ChugSplashDeployer.isUpgrading.selector\\n            )\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(\\n                ret == 0,\\n                \\\"L1ChugSplashProxy: system is currently being upgraded\\\"\\n            );\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * Makes a proxy call instead of triggering the given function when the caller is either the\\n     * owner or the zero address. Caller can only ever be the zero address if this function is\\n     * being called off-chain via eth_call, which is totally fine and can be convenient for\\n     * client-side tooling. Avoids situations where the proxy and implementation share a sighash\\n     * and the proxy function ends up being called instead of the implementation one.\\n     *\\n     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a\\n     * way for someone to send a transaction with msg.sender == address(0) in any real context then\\n     * we have much bigger problems. Primary reason to include this additional allowed sender is\\n     * because the owner address can be changed dynamically and we do not want clients to have to\\n     * keep track of the current owner in order to make an eth_call that doesn't trigger the\\n     * proxied contract.\\n     */\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n\\n    /*********************\\n     * Fallback Function *\\n     *********************/\\n\\n    fallback()\\n        external\\n        payable\\n    {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the code that should be running behind this proxy. Note that this scheme is a bit\\n     * different from the standard proxy scheme where one would typically deploy the code\\n     * separately and then set the implementation address. We're doing it this way because it gives\\n     * us a lot more freedom on the client side. Can only be triggered by the contract owner.\\n     * @param _code New contract code to run inside this contract.\\n     */\\n    function setCode(\\n        bytes memory _code\\n    )\\n        proxyCallIfNotOwner\\n        public\\n    {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(\\n            DEPLOY_CODE_PREFIX,\\n            _code\\n        );\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed.\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /**\\n     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform\\n     * upgrades in a more transparent way. Only callable by the owner.\\n     * @param _key Storage key to modify.\\n     * @param _value New value for the storage key.\\n     */\\n    function setStorage(\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        proxyCallIfNotOwner\\n        public\\n    {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract. Only callable by the owner.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function setOwner(\\n        address _owner\\n    )\\n        proxyCallIfNotOwner\\n        public\\n    {\\n        _setOwner(_owner);\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Owner address.\\n     */\\n    function getOwner()\\n        proxyCallIfNotOwner\\n        public\\n        returns (\\n            address\\n        )\\n    {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * Queries the implementation address. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Implementation address.\\n     */\\n    function getImplementation()\\n        proxyCallIfNotOwner\\n        public\\n        returns (\\n            address\\n        )\\n    {\\n        return _getImplementation();\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Sets the implementation address.\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(\\n        address _implementation\\n    )\\n        internal\\n    {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /**\\n     * Queries the implementation address.\\n     * @return Implementation address.\\n     */\\n    function _getImplementation()\\n        internal\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function _setOwner(\\n        address _owner\\n    )\\n        internal\\n    {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract.\\n     * @return Owner address.\\n     */\\n    function _getOwner()\\n        internal\\n        view \\n        returns (\\n            address\\n        )\\n    {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * Gets the code hash for a given account.\\n     * @param _account Address of the account to get a code hash for.\\n     * @return Code hash for the account.\\n     */\\n    function _getAccountCodeHash(\\n        address _account\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n\\n    /**\\n     * Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall()\\n        onlyWhenNotPaused\\n        internal\\n    {\\n        address implementation = _getImplementation();\\n\\n        require(\\n            implementation != address(0),\\n            \\\"L1ChugSplashProxy: implementation is not set yet\\\"\\n        );\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n            \\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/chugsplash/interfaces/iL1ChugSplashDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iL1ChugSplashDeployer\\n */\\ninterface iL1ChugSplashDeployer {\\n    function isUpgrading()\\n        external\\n        view\\n        returns (\\n            bool\\n        );\\n}\\n\"\r\n    }\r\n  }\r\n}}"}, {"protocol": "Optimism", "timeStamp": "1633370117", "hash": "0xb957ff6ec7cef3752872e4f511187e5e9b3f183c62832d87d12bc1774fb045a2", "contractAddress": "0x9996571372066a1545d3435c6935e3f9593a7ef5", "SourceCode": ""}, {"protocol": "Optimism", "timeStamp": "1624408260", "hash": "0x1a5950c8bda63acbf3e5e2e449ccffa235b89cbd26ad86f37df58e76d9e5f9bc", "contractAddress": "0x622fcf71453b7ba0237b7ae80855297397c1c303", "SourceCode": ""}, {"protocol": "Optimism", "timeStamp": "1624406009", "hash": "0x0aba85be8deee74cba97692c5ab92b00c123ad23fcaf3223676454c96128d835", "contractAddress": "0x622fcf71453b7ba0237b7ae80855297397c1c303", "SourceCode": ""}, {"protocol": "Optimism", "timeStamp": "1624405309", "hash": "0xfa30d1b080d2f23b038f8d5b83e626c99c9a4071d1c391902b5cefdc9964fe64", "contractAddress": "0x622fcf71453b7ba0237b7ae80855297397c1c303", "SourceCode": ""}, {"protocol": "Optimism", "timeStamp": "1624401578", "hash": "0xeac41ff6ae58b4836c8b30bb7dabc8bf38df3056a0c66a4e8404142a8a429329", "contractAddress": "0xde1fcfb0851916ca5101820a69b13a4e276bd81f", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string indexed _name,\\n        address _newAddress,\\n        address _oldAddress\\n    );\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(\\n            _name,\\n            _address,\\n            oldAddress\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(\\n        string memory _name\\n    )\\n        external\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}"}, {"protocol": "Optimism", "timeStamp": "1624401555", "hash": "0x5fe73adb2da599a4825f64427c9fa3839fafd318998ba04e5a8b20502b8bef2f", "contractAddress": "0xde1fcfb0851916ca5101820a69b13a4e276bd81f", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string indexed _name,\\n        address _newAddress,\\n        address _oldAddress\\n    );\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(\\n            _name,\\n            _address,\\n            oldAddress\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(\\n        string memory _name\\n    )\\n        external\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}"}][{"protocol": "adidas Originals", "timeStamp": "1686182123", "hash": "0xfdce76f0b8912396fac910cb5ce847f460433912f25fd4ffb3609837c80a26e9", "contractAddress": "0x8bf0ca07d85c886cd7d56587c0cdc4306f871726", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract GoldenTicket is\\n    ERC721AQueryable,\\n    ERC2981,\\n    Ownable,\\n    Pausable,\\n    DefaultOperatorFilterer\\n{\\n    string private _name;\\n    string private _symbol;\\n    string public baseUri;\\n\\n    mapping(uint256 => bool) private lockedTokens;\\n    mapping(address => bool) public permittedOperators;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        address recipient,\\n        uint96 value\\n    ) ERC721A(_name, _symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice The name of the ERC721 token.\\n    function name()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /// @notice The symbol of the ERC721 token.\\n    function symbol()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /// @notice Sets the name and symbol of the ERC721 token.\\n    /// @param newName The new name for the token.\\n    /// @param newSymbol The new symbol for the token.\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) external onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    /// @notice The token base URI.\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Sets the base URI for the token metadata.\\n    /// @param _baseUri The new base URI for the token metadata.\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Pauses the contract, preventing token transfers.\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses the contract, allowing token transfers.\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n    /// @param to An array of addresses to which tokens will be minted.\\n    /// @param value An array of values representing the number of tokens to mint for each address.\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the royalty fee for the specified recipient.\\n    /// @param recipient The address of the royalty recipient.\\n    /// @param value The value of the royalty fee.\\n    function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice Locks the specified tokens, preventing them from being transferred.\\n    /// @param tokenIds An array of token IDs to be locked.\\n    function lockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(!lockedTokens[tokenIds[i]], \\\"Token is already locked\\\");\\n            lockedTokens[tokenIds[i]] = true;\\n        }\\n    }\\n\\n    /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n    /// @param tokenIds An array of token IDs to be unlocked.\\n    function unlockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(lockedTokens[tokenIds[i]], \\\"Token is already unlocked\\\");\\n            lockedTokens[tokenIds[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Admin function to burn and redeem the golden ticket.\\n    /// @param tokenIds An array of locked token IDs to be burned.\\n    function burnLockedTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                lockedTokens[tokenIds[i]],\\n                \\\"Token must be locked before burning\\\"\\n            );\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Adds multiple addresses as permitted operators.\\n    /// @param operators An array of addresses to be added as permitted operators.\\n    function addPermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            if (!permittedOperators[operators[i]]) {\\n                permittedOperators[operators[i]] = true;\\n            }\\n        }\\n    }\\n\\n    /// @notice Removes multiple addresses from the permitted operators list.\\n    /// @param operators An array of addresses to be removed from the permitted operators list.\\n    function removePermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            permittedOperators[operators[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Retrieves the lock statuses of the specified tokens.\\n    /// @param tokenIds An array of token IDs to check the lock status.\\n    /// @return An array of boolean values representing the lock statuses of the tokens.\\n    function getTokenLockStatuses(\\n        uint256[] memory tokenIds\\n    ) public view returns (bool[] memory) {\\n        bool[] memory lockStatuses = new bool[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lockStatuses[i] = lockedTokens[tokenIds[i]];\\n        }\\n        return lockStatuses;\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (\\n                from != address(0) &&\\n                from != owner() &&\\n                !permittedOperators[from]\\n            ) {\\n                require(\\n                    !lockedTokens[i],\\n                    \\\"Token is locked and cannot be transferred\\\"\\n                );\\n            }\\n            if (lockedTokens[i]) {\\n                require(\\n                    msg.sender == owner() || permittedOperators[msg.sender],\\n                    \\\"Not an allowed operator\\\"\\n                );\\n            }\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(\\n        address operator,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1686181931", "hash": "0xb160d8e44cbb29e0358d5427063af44672ae22167d4eca9cea53375bfd501b9c", "contractAddress": "0x55ad4e148394212be7b952ebeaa6e24f8a43bb2c", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/BitMaps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largely inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        return bitmap._data[bucket] & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\\n        if (value) {\\n            set(bitmap, index);\\n        } else {\\n            unset(bitmap, index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] |= mask;\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] &= ~mask;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport 'erc721a/contracts/extensions/ERC721AQueryable.sol';\\nimport 'operator-filter-registry/src/DefaultOperatorFilterer.sol';\\nimport '@openzeppelin/contracts/token/common/ERC2981.sol';\\nimport '@openzeppelin/contracts/security/Pausable.sol';\\nimport '@openzeppelin/contracts/utils/structs/BitMaps.sol';\\n\\ncontract GoldenTicket is ERC721AQueryable, ERC2981, Ownable, Pausable, DefaultOperatorFilterer {\\n   string private _name;\\n   string private _symbol;\\n   string private _contractUri;\\n   string public baseUri;\\n\\n   BitMaps.BitMap private lockedTokens;\\n   BitMaps.BitMap private redeemedTokens;\\n   mapping(address => bool) public permittedOperators;\\n\\n   constructor(\\n      string memory __name,\\n      string memory __symbol,\\n      string memory __contractUri,\\n      string memory _baseUri,\\n      address recipient,\\n      uint96 value\\n   ) ERC721A(_name, _symbol) {\\n      _name = __name;\\n      _symbol = __symbol;\\n      _contractUri = __contractUri;\\n      baseUri = _baseUri;\\n      _setDefaultRoyalty(recipient, value);\\n      _pause();\\n   }\\n\\n   modifier onlyPermittedOperator() {\\n      require(permittedOperators[msg.sender] || msg.sender == owner(), 'Not a permitted operator');\\n      _;\\n   }\\n\\n   /// @notice The name of the ERC721 token.\\n   function name() public view override(ERC721A, IERC721A) returns (string memory) {\\n      return _name;\\n   }\\n\\n   /// @notice The symbol of the ERC721 token.\\n   function symbol() public view override(ERC721A, IERC721A) returns (string memory) {\\n      return _symbol;\\n   }\\n\\n   /// @notice Sets the name and symbol of the ERC721 token.\\n   /// @param newName The new name for the token.\\n   /// @param newSymbol The new symbol for the token.\\n   function setNameAndSymbol(\\n      string calldata newName,\\n      string calldata newSymbol\\n   ) external onlyOwner {\\n      _name = newName;\\n      _symbol = newSymbol;\\n   }\\n\\n   /// @notice The token base URI.\\n   function _baseURI() internal view override returns (string memory) {\\n      return baseUri;\\n   }\\n\\n   /// @notice Sets the base URI for the token metadata.\\n   /// @param newBaseUri The new base URI for the token metadata.\\n   function setBaseUri(string calldata newBaseUri) external onlyOwner {\\n      baseUri = newBaseUri;\\n   }\\n\\n   /// @notice Sets the URI for the contract metadata.\\n   /// @param newContractUri The new contract URI for contract metadata.\\n   function setContractURI(string calldata newContractUri) external onlyOwner {\\n      _contractUri = newContractUri;\\n   }\\n\\n   /// @notice Sets the contract URI for marketplace listings.\\n   function contractURI() public view returns (string memory) {\\n      return _contractUri;\\n   }\\n\\n   /// @notice Pauses the contract, preventing token transfers.\\n   function pause() public onlyOwner {\\n      _pause();\\n   }\\n\\n   /// @notice Unpauses the contract, allowing token transfers.\\n   function unpause() public onlyOwner {\\n      _unpause();\\n   }\\n\\n   /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n   /// @param to An array of addresses to which tokens will be minted.\\n   /// @param value An array of values representing the number of tokens to mint for each address.\\n   function mintMany(address[] calldata to, uint256[] calldata value) external onlyOwner {\\n      require(to.length == value.length, 'Mismatched lengths');\\n      unchecked {\\n         for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n         }\\n      }\\n   }\\n\\n   /// @notice Sets the royalty fee for the specified recipient.\\n   /// @param recipient The address of the royalty recipient.\\n   /// @param value The value of the royalty fee.\\n   function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n      _setDefaultRoyalty(recipient, value);\\n   }\\n\\n   /// @notice Locks the specified tokens, preventing them from being transferred.\\n   /// @param tokenIds An array of token IDs to be locked.\\n   function lockTokens(uint256[] calldata tokenIds) external onlyPermittedOperator {\\n      unchecked {\\n         for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(_exists(tokenIds[i]), 'Token does not exist.');\\n            require(!BitMaps.get(lockedTokens, tokenIds[i]), 'Token is already locked');\\n            BitMaps.set(lockedTokens, tokenIds[i]);\\n         }\\n      }\\n   }\\n\\n   /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n   /// @param tokenIds An array of token IDs to be unlocked.\\n   function unlockTokens(uint256[] calldata tokenIds) external onlyPermittedOperator {\\n      unchecked {\\n         for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(BitMaps.get(lockedTokens, tokenIds[i]), 'Token is already unlocked');\\n            BitMaps.unset(lockedTokens, tokenIds[i]);\\n         }\\n      }\\n   }\\n\\n   /// @notice Check if a token is locked.\\n   /// @param tokenId The tokenId of the token to check.\\n   function isTokenLocked(uint256 tokenId) public view returns (bool) {\\n      return BitMaps.get(lockedTokens, tokenId);\\n   }\\n\\n   /// @notice Check if a token has be burned and redeemed.\\n   /// @param tokenId The tokenId of the token to check.\\n   function isTokenRedeemed(uint256 tokenId) public view returns (bool) {\\n      return BitMaps.get(redeemedTokens, tokenId);\\n   }\\n\\n   /// @notice Get tokenIds of all locked tokens in a given range.\\n   /// @param start The start tokenId of the range to check.\\n   /// @param end The end tokenId of the range to check.\\n   function getLockedTokensInRange(\\n      uint256 start,\\n      uint256 end\\n   ) public view returns (uint256[] memory) {\\n      require(end >= start, 'End must be greater than or equal to start');\\n      uint256[] memory result = new uint256[](end - start + 1);\\n      uint256 count = 0;\\n      unchecked {\\n         for (uint256 i = start; i <= end; i++) {\\n            if (BitMaps.get(lockedTokens, i)) {\\n               result[count] = i;\\n               count++;\\n            }\\n         }\\n      }\\n      uint256[] memory tokens = new uint256[](count);\\n      unchecked {\\n         for (uint256 i = 0; i < count; i++) {\\n            tokens[i] = result[i];\\n         }\\n      }\\n      return tokens;\\n   }\\n\\n   /// @notice Get tokenIds of all redeemed tokens in a given range.\\n   /// @param start The start tokenId of the range to check.\\n   /// @param end The end tokenId of the range to check.\\n   function getRedeemedTokensInRange(\\n      uint256 start,\\n      uint256 end\\n   ) public view returns (uint256[] memory) {\\n      require(end >= start, 'End must be greater than or equal to start');\\n      uint256[] memory result = new uint256[](end - start + 1);\\n      uint256 count = 0;\\n      unchecked {\\n         for (uint256 i = start; i <= end; i++) {\\n            if (BitMaps.get(redeemedTokens, i)) {\\n               result[count] = i;\\n               count++;\\n            }\\n         }\\n      }\\n      uint256[] memory redeemedTokensInRange = new uint256[](count);\\n      unchecked {\\n         for (uint256 i = 0; i < count; i++) {\\n            redeemedTokensInRange[i] = result[i];\\n         }\\n      }\\n      return redeemedTokensInRange;\\n   }\\n\\n   /// @notice Admin function to burn and redeem the golden ticket.\\n   /// @param tokenIds An array of locked token IDs to be burned.\\n   function burnAndRedeem(uint256[] calldata tokenIds) external onlyPermittedOperator {\\n      unchecked {\\n         for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n               BitMaps.get(lockedTokens, tokenIds[i]),\\n               'Token must be locked before burn/redemption'\\n            );\\n            _burn(tokenIds[i]);\\n            BitMaps.set(redeemedTokens, tokenIds[i]);\\n         }\\n      }\\n   }\\n\\n   /// @notice Adds multiple addresses as permitted operators.\\n   /// @param operators An array of addresses to be added as permitted operators.\\n   function addPermittedOperators(address[] calldata operators) external onlyOwner {\\n      for (uint256 i = 0; i < operators.length; i++) {\\n         require(!permittedOperators[operators[i]], 'At least one operator is already permitted');\\n         permittedOperators[operators[i]] = true;\\n      }\\n   }\\n\\n   /// @notice Removes multiple addresses from the permitted operators list.\\n   /// @param operators An array of addresses to be removed from the permitted operators list.\\n   function removePermittedOperators(address[] calldata operators) external onlyOwner {\\n      for (uint256 i = 0; i < operators.length; i++) {\\n         permittedOperators[operators[i]] = false;\\n      }\\n   }\\n\\n   /// @dev Ensure that a user cannot burn or transfer a locked golden ticket unless that user is a permitted operator\\n   function _beforeTokenTransfers(\\n      address from,\\n      address to,\\n      uint256 startTokenId,\\n      uint256 quantity\\n   ) internal override {\\n      unchecked {\\n         for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (BitMaps.get(lockedTokens, i)) {\\n               require(\\n                  permittedOperators[msg.sender] || msg.sender == owner(),\\n                  'At least one token is locked and cannot be transferred.'\\n               );\\n            }\\n         }\\n      }\\n      super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n   }\\n\\n   function setApprovalForAll(\\n      address operator,\\n      bool approved\\n   ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) whenNotPaused {\\n      super.setApprovalForAll(operator, approved);\\n   }\\n\\n   function approve(\\n      address operator,\\n      uint256 tokenId\\n   )\\n      public\\n      payable\\n      override(ERC721A, IERC721A)\\n      onlyAllowedOperatorApproval(operator)\\n      whenNotPaused\\n   {\\n      if (BitMaps.get(lockedTokens, tokenId)) {\\n         require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            'Token must not be locked to grant approval.'\\n         );\\n      }\\n      super.approve(operator, tokenId);\\n   }\\n\\n   function transferFrom(\\n      address from,\\n      address to,\\n      uint256 tokenId\\n   ) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) whenNotPaused {\\n      super.transferFrom(from, to, tokenId);\\n   }\\n\\n   function safeTransferFrom(\\n      address from,\\n      address to,\\n      uint256 tokenId\\n   ) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) whenNotPaused {\\n      super.safeTransferFrom(from, to, tokenId);\\n   }\\n\\n   function safeTransferFrom(\\n      address from,\\n      address to,\\n      uint256 tokenId,\\n      bytes memory data\\n   ) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) whenNotPaused {\\n      super.safeTransferFrom(from, to, tokenId, data);\\n   }\\n\\n   /// @dev Supports `interfaceId`s for IERC165, IERC721, IERC721Metadata, IERC2981\\n   function supportsInterface(\\n      bytes4 interfaceId\\n   ) public view override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n      return ERC721A.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId);\\n   }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) _revert(URIQueryForNonexistentToken.selector);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Returns whether the ownership slot at `index` is initialized.\\n     * An uninitialized slot does not necessarily mean that the slot has no owner.\\n     */\\n    function _ownershipIsInitialized(uint256 index) internal view virtual returns (bool) {\\n        return _packedOwnerships[index] != 0;\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {\\n        if (_startTokenId() <= tokenId) {\\n            packed = _packedOwnerships[tokenId];\\n            // If the data at the starting slot does not exist, start the scan.\\n            if (packed == 0) {\\n                if (tokenId >= _currentIndex) _revert(OwnerQueryForNonexistentToken.selector);\\n                // Invariant:\\n                // There will always be an initialized ownership slot\\n                // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                // before an unintialized ownership slot\\n                // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                // Hence, `tokenId` will not underflow.\\n                //\\n                // We can directly compare the packed value.\\n                // If the address is zero, packed will be zero.\\n                for (;;) {\\n                    unchecked {\\n                        packed = _packedOwnerships[--tokenId];\\n                    }\\n                    if (packed == 0) continue;\\n                    if (packed & _BITMASK_BURNED == 0) return packed;\\n                    // Otherwise, the token is burned, and we must revert.\\n                    // This handles the case of batch burned tokens, where only the burned bit\\n                    // of the starting slot is set, and remaining slots are left uninitialized.\\n                    _revert(OwnerQueryForNonexistentToken.selector);\\n                }\\n            }\\n            // Otherwise, the data exists and we can skip the scan.\\n            // This is possible because we have already achieved the target condition.\\n            // This saves 2143 gas on transfers of initialized tokens.\\n            // If the token is not burned, return `packed`. Otherwise, revert.\\n            if (packed & _BITMASK_BURNED == 0) return packed;\\n        }\\n        _revert(OwnerQueryForNonexistentToken.selector);\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        _approve(to, tokenId, true);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool result) {\\n        if (_startTokenId() <= tokenId) {\\n            if (tokenId < _currentIndex) {\\n                uint256 packed;\\n                while ((packed = _packedOwnerships[tokenId]) == 0) --tokenId;\\n                result = packed & _BITMASK_BURNED == 0;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        // Mask `from` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n        from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS));\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) _revert(TransferFromIncorrectOwner.selector);\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n        uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\\n        assembly {\\n            // Emit the `Transfer` event.\\n            log4(\\n                0, // Start of data (0, since no data).\\n                0, // End of data (0, since no data).\\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                from, // `from`.\\n                toMasked, // `to`.\\n                tokenId // `tokenId`.\\n            )\\n        }\\n        if (toMasked == 0) _revert(TransferToZeroAddress.selector);\\n\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\\n            }\\n            assembly {\\n                revert(add(32, reason), mload(reason))\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\\n\\n            if (toMasked == 0) _revert(MintToZeroAddress.selector);\\n\\n            uint256 end = startTokenId + quantity;\\n            uint256 tokenId = startTokenId;\\n\\n            do {\\n                assembly {\\n                    // Emit the `Transfer` event.\\n                    log4(\\n                        0, // Start of data (0, since no data).\\n                        0, // End of data (0, since no data).\\n                        _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                        0, // `address(0)`.\\n                        toMasked, // `to`.\\n                        tokenId // `tokenId`.\\n                    )\\n                }\\n                // The `!=` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n            } while (++tokenId != end);\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) _revert(MintToZeroAddress.selector);\\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) _revert(MintERC2309QuantityExceedsLimit.selector);\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        _revert(TransferToNonERC721ReceiverImplementer.selector);\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) _revert(bytes4(0));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                       APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_approve(to, tokenId, false)`.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _approve(to, tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        bool approvalCheck\\n    ) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        if (approvalCheck && _msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                _revert(ApprovalCallerNotOwnerNorApproved.selector);\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) _revert(OwnershipNotInitializedForExtraData.selector);\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /**\\n     * @dev For more efficient reverts.\\n     */\\n    function _revert(bytes4 errorSelector) internal pure {\\n        assembly {\\n            mstore(0x00, errorSelector)\\n            revert(0x00, 0x04)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership memory ownership)\\n    {\\n        unchecked {\\n            if (tokenId >= _startTokenId()) {\\n                if (tokenId < _nextTokenId()) {\\n                    // If the `tokenId` is within bounds,\\n                    // scan backwards for the initialized ownership slot.\\n                    while (!_ownershipIsInitialized(tokenId)) --tokenId;\\n                    return _ownershipAt(tokenId);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        TokenOwnership[] memory ownerships;\\n        uint256 i = tokenIds.length;\\n        assembly {\\n            // Grab the free memory pointer.\\n            ownerships := mload(0x40)\\n            // Store the length.\\n            mstore(ownerships, i)\\n            // Allocate one word for the length,\\n            // `tokenIds.length` words for the pointers.\\n            i := shl(5, i) // Multiply `i` by 32.\\n            mstore(0x40, add(add(ownerships, 0x20), i))\\n        }\\n        while (i != 0) {\\n            uint256 tokenId;\\n            assembly {\\n                i := sub(i, 0x20)\\n                tokenId := calldataload(add(tokenIds.offset, i))\\n            }\\n            TokenOwnership memory ownership = explicitOwnershipOf(tokenId);\\n            assembly {\\n                // Store the pointer of `ownership` in the `ownerships` array.\\n                mstore(add(add(ownerships, 0x20), i), ownership)\\n            }\\n        }\\n        return ownerships;\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        return _tokensOfOwnerIn(owner, start, stop);\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        uint256 start = _startTokenId();\\n        uint256 stop = _nextTokenId();\\n        uint256[] memory tokenIds;\\n        if (start != stop) tokenIds = _tokensOfOwnerIn(owner, start, stop);\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev Helper function for returning an array of token IDs owned by `owner`.\\n     *\\n     * Note that this function is optimized for smaller bytecode size over runtime gas,\\n     * since it is meant to be called off-chain.\\n     */\\n    function _tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) private view returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) _revert(InvalidQueryRange.selector);\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop >= stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256[] memory tokenIds;\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            bool startLtStop = start < stop;\\n            assembly {\\n                // Set `tokenIdsMaxLength` to zero if `start` is less than `stop`.\\n                tokenIdsMaxLength := mul(tokenIdsMaxLength, startLtStop)\\n            }\\n            if (tokenIdsMaxLength != 0) {\\n                // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n                // to cater for cases where `balanceOf(owner)` is too big.\\n                if (stop - start <= tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = stop - start;\\n                }\\n                assembly {\\n                    // Grab the free memory pointer.\\n                    tokenIds := mload(0x40)\\n                    // Allocate one word for the length, and `tokenIdsMaxLength` words\\n                    // for the data. `shl(5, x)` is equivalent to `mul(32, x)`.\\n                    mstore(0x40, add(tokenIds, shl(5, add(tokenIdsMaxLength, 1))))\\n                }\\n                // We need to call `explicitOwnershipOf(start)`,\\n                // because the slot at `start` may not be initialized.\\n                TokenOwnership memory ownership = explicitOwnershipOf(start);\\n                address currOwnershipAddr;\\n                // If the starting slot exists (i.e. not burned),\\n                // initialize `currOwnershipAddr`.\\n                // `ownership.address` will not be zero,\\n                // as `start` is clamped to the valid token ID range.\\n                if (!ownership.burned) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                uint256 tokenIdsIdx;\\n                // Use a do-while, which is slightly more efficient for this case,\\n                // as the array will at least contain one element.\\n                do {\\n                    ownership = _ownershipAt(start);\\n                    assembly {\\n                        switch mload(add(ownership, 0x40))\\n                        // if `ownership.burned == false`.\\n                        case 0 {\\n                            // if `ownership.addr != address(0)`.\\n                            // The `addr` already has it's upper 96 bits clearned,\\n                            // since it is written to memory with regular Solidity.\\n                            if mload(ownership) {\\n                                currOwnershipAddr := mload(ownership)\\n                            }\\n                            // if `currOwnershipAddr == owner`.\\n                            // The `shl(96, x)` is to make the comparison agnostic to any\\n                            // dirty upper 96 bits in `owner`.\\n                            if iszero(shl(96, xor(currOwnershipAddr, owner))) {\\n                                tokenIdsIdx := add(tokenIdsIdx, 1)\\n                                mstore(add(tokenIds, shl(5, tokenIdsIdx)), start)\\n                            }\\n                        }\\n                        // Otherwise, reset `currOwnershipAddr`.\\n                        // This handles the case of batch burned tokens\\n                        // (burned bit of first slot set, remaining slots left uninitialized).\\n                        default {\\n                            currOwnershipAddr := 0\\n                        }\\n                        start := add(start, 1)\\n                    }\\n                } while (!(start == stop || tokenIdsIdx == tokenIdsMaxLength));\\n                // Store the length of the array.\\n                assembly {\\n                    mstore(tokenIds, tokenIdsIdx)\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1686181763", "hash": "0x9400801d5815d7de7cb52d971f4b29ec8a190de3e812513bd562b871ee87e249", "contractAddress": "0x8bf0ca07d85c886cd7d56587c0cdc4306f871726", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract GoldenTicket is\\n    ERC721AQueryable,\\n    ERC2981,\\n    Ownable,\\n    Pausable,\\n    DefaultOperatorFilterer\\n{\\n    string private _name;\\n    string private _symbol;\\n    string public baseUri;\\n\\n    mapping(uint256 => bool) private lockedTokens;\\n    mapping(address => bool) public permittedOperators;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        address recipient,\\n        uint96 value\\n    ) ERC721A(_name, _symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice The name of the ERC721 token.\\n    function name()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /// @notice The symbol of the ERC721 token.\\n    function symbol()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /// @notice Sets the name and symbol of the ERC721 token.\\n    /// @param newName The new name for the token.\\n    /// @param newSymbol The new symbol for the token.\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) external onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    /// @notice The token base URI.\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Sets the base URI for the token metadata.\\n    /// @param _baseUri The new base URI for the token metadata.\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Pauses the contract, preventing token transfers.\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses the contract, allowing token transfers.\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n    /// @param to An array of addresses to which tokens will be minted.\\n    /// @param value An array of values representing the number of tokens to mint for each address.\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the royalty fee for the specified recipient.\\n    /// @param recipient The address of the royalty recipient.\\n    /// @param value The value of the royalty fee.\\n    function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice Locks the specified tokens, preventing them from being transferred.\\n    /// @param tokenIds An array of token IDs to be locked.\\n    function lockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(!lockedTokens[tokenIds[i]], \\\"Token is already locked\\\");\\n            lockedTokens[tokenIds[i]] = true;\\n        }\\n    }\\n\\n    /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n    /// @param tokenIds An array of token IDs to be unlocked.\\n    function unlockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(lockedTokens[tokenIds[i]], \\\"Token is already unlocked\\\");\\n            lockedTokens[tokenIds[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Admin function to burn and redeem the golden ticket.\\n    /// @param tokenIds An array of locked token IDs to be burned.\\n    function burnLockedTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                lockedTokens[tokenIds[i]],\\n                \\\"Token must be locked before burning\\\"\\n            );\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Adds multiple addresses as permitted operators.\\n    /// @param operators An array of addresses to be added as permitted operators.\\n    function addPermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            if (!permittedOperators[operators[i]]) {\\n                permittedOperators[operators[i]] = true;\\n            }\\n        }\\n    }\\n\\n    /// @notice Removes multiple addresses from the permitted operators list.\\n    /// @param operators An array of addresses to be removed from the permitted operators list.\\n    function removePermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            permittedOperators[operators[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Retrieves the lock statuses of the specified tokens.\\n    /// @param tokenIds An array of token IDs to check the lock status.\\n    /// @return An array of boolean values representing the lock statuses of the tokens.\\n    function getTokenLockStatuses(\\n        uint256[] memory tokenIds\\n    ) public view returns (bool[] memory) {\\n        bool[] memory lockStatuses = new bool[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lockStatuses[i] = lockedTokens[tokenIds[i]];\\n        }\\n        return lockStatuses;\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (\\n                from != address(0) &&\\n                from != owner() &&\\n                !permittedOperators[from]\\n            ) {\\n                require(\\n                    !lockedTokens[i],\\n                    \\\"Token is locked and cannot be transferred\\\"\\n                );\\n            }\\n            if (lockedTokens[i]) {\\n                require(\\n                    msg.sender == owner() || permittedOperators[msg.sender],\\n                    \\\"Not an allowed operator\\\"\\n                );\\n            }\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(\\n        address operator,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1686181751", "hash": "0x66fe05874159f646d71f25fd35294b70ff9bd9dca1bc485e43366833870b9530", "contractAddress": "0x8bf0ca07d85c886cd7d56587c0cdc4306f871726", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract GoldenTicket is\\n    ERC721AQueryable,\\n    ERC2981,\\n    Ownable,\\n    Pausable,\\n    DefaultOperatorFilterer\\n{\\n    string private _name;\\n    string private _symbol;\\n    string public baseUri;\\n\\n    mapping(uint256 => bool) private lockedTokens;\\n    mapping(address => bool) public permittedOperators;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        address recipient,\\n        uint96 value\\n    ) ERC721A(_name, _symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice The name of the ERC721 token.\\n    function name()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /// @notice The symbol of the ERC721 token.\\n    function symbol()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /// @notice Sets the name and symbol of the ERC721 token.\\n    /// @param newName The new name for the token.\\n    /// @param newSymbol The new symbol for the token.\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) external onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    /// @notice The token base URI.\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Sets the base URI for the token metadata.\\n    /// @param _baseUri The new base URI for the token metadata.\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Pauses the contract, preventing token transfers.\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses the contract, allowing token transfers.\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n    /// @param to An array of addresses to which tokens will be minted.\\n    /// @param value An array of values representing the number of tokens to mint for each address.\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the royalty fee for the specified recipient.\\n    /// @param recipient The address of the royalty recipient.\\n    /// @param value The value of the royalty fee.\\n    function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice Locks the specified tokens, preventing them from being transferred.\\n    /// @param tokenIds An array of token IDs to be locked.\\n    function lockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(!lockedTokens[tokenIds[i]], \\\"Token is already locked\\\");\\n            lockedTokens[tokenIds[i]] = true;\\n        }\\n    }\\n\\n    /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n    /// @param tokenIds An array of token IDs to be unlocked.\\n    function unlockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(lockedTokens[tokenIds[i]], \\\"Token is already unlocked\\\");\\n            lockedTokens[tokenIds[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Admin function to burn and redeem the golden ticket.\\n    /// @param tokenIds An array of locked token IDs to be burned.\\n    function burnLockedTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                lockedTokens[tokenIds[i]],\\n                \\\"Token must be locked before burning\\\"\\n            );\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Adds multiple addresses as permitted operators.\\n    /// @param operators An array of addresses to be added as permitted operators.\\n    function addPermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            if (!permittedOperators[operators[i]]) {\\n                permittedOperators[operators[i]] = true;\\n            }\\n        }\\n    }\\n\\n    /// @notice Removes multiple addresses from the permitted operators list.\\n    /// @param operators An array of addresses to be removed from the permitted operators list.\\n    function removePermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            permittedOperators[operators[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Retrieves the lock statuses of the specified tokens.\\n    /// @param tokenIds An array of token IDs to check the lock status.\\n    /// @return An array of boolean values representing the lock statuses of the tokens.\\n    function getTokenLockStatuses(\\n        uint256[] memory tokenIds\\n    ) public view returns (bool[] memory) {\\n        bool[] memory lockStatuses = new bool[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lockStatuses[i] = lockedTokens[tokenIds[i]];\\n        }\\n        return lockStatuses;\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (\\n                from != address(0) &&\\n                from != owner() &&\\n                !permittedOperators[from]\\n            ) {\\n                require(\\n                    !lockedTokens[i],\\n                    \\\"Token is locked and cannot be transferred\\\"\\n                );\\n            }\\n            if (lockedTokens[i]) {\\n                require(\\n                    msg.sender == owner() || permittedOperators[msg.sender],\\n                    \\\"Not an allowed operator\\\"\\n                );\\n            }\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(\\n        address operator,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1686181727", "hash": "0x5e0348fab860d5e3dba0bec267e063bbe63ca39ded021e369bd3e0b100dfa52c", "contractAddress": "0x8bf0ca07d85c886cd7d56587c0cdc4306f871726", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract GoldenTicket is\\n    ERC721AQueryable,\\n    ERC2981,\\n    Ownable,\\n    Pausable,\\n    DefaultOperatorFilterer\\n{\\n    string private _name;\\n    string private _symbol;\\n    string public baseUri;\\n\\n    mapping(uint256 => bool) private lockedTokens;\\n    mapping(address => bool) public permittedOperators;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        address recipient,\\n        uint96 value\\n    ) ERC721A(_name, _symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice The name of the ERC721 token.\\n    function name()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /// @notice The symbol of the ERC721 token.\\n    function symbol()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /// @notice Sets the name and symbol of the ERC721 token.\\n    /// @param newName The new name for the token.\\n    /// @param newSymbol The new symbol for the token.\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) external onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    /// @notice The token base URI.\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Sets the base URI for the token metadata.\\n    /// @param _baseUri The new base URI for the token metadata.\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Pauses the contract, preventing token transfers.\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses the contract, allowing token transfers.\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n    /// @param to An array of addresses to which tokens will be minted.\\n    /// @param value An array of values representing the number of tokens to mint for each address.\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the royalty fee for the specified recipient.\\n    /// @param recipient The address of the royalty recipient.\\n    /// @param value The value of the royalty fee.\\n    function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice Locks the specified tokens, preventing them from being transferred.\\n    /// @param tokenIds An array of token IDs to be locked.\\n    function lockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(!lockedTokens[tokenIds[i]], \\\"Token is already locked\\\");\\n            lockedTokens[tokenIds[i]] = true;\\n        }\\n    }\\n\\n    /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n    /// @param tokenIds An array of token IDs to be unlocked.\\n    function unlockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(lockedTokens[tokenIds[i]], \\\"Token is already unlocked\\\");\\n            lockedTokens[tokenIds[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Admin function to burn and redeem the golden ticket.\\n    /// @param tokenIds An array of locked token IDs to be burned.\\n    function burnLockedTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                lockedTokens[tokenIds[i]],\\n                \\\"Token must be locked before burning\\\"\\n            );\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Adds multiple addresses as permitted operators.\\n    /// @param operators An array of addresses to be added as permitted operators.\\n    function addPermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            if (!permittedOperators[operators[i]]) {\\n                permittedOperators[operators[i]] = true;\\n            }\\n        }\\n    }\\n\\n    /// @notice Removes multiple addresses from the permitted operators list.\\n    /// @param operators An array of addresses to be removed from the permitted operators list.\\n    function removePermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            permittedOperators[operators[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Retrieves the lock statuses of the specified tokens.\\n    /// @param tokenIds An array of token IDs to check the lock status.\\n    /// @return An array of boolean values representing the lock statuses of the tokens.\\n    function getTokenLockStatuses(\\n        uint256[] memory tokenIds\\n    ) public view returns (bool[] memory) {\\n        bool[] memory lockStatuses = new bool[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lockStatuses[i] = lockedTokens[tokenIds[i]];\\n        }\\n        return lockStatuses;\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (\\n                from != address(0) &&\\n                from != owner() &&\\n                !permittedOperators[from]\\n            ) {\\n                require(\\n                    !lockedTokens[i],\\n                    \\\"Token is locked and cannot be transferred\\\"\\n                );\\n            }\\n            if (lockedTokens[i]) {\\n                require(\\n                    msg.sender == owner() || permittedOperators[msg.sender],\\n                    \\\"Not an allowed operator\\\"\\n                );\\n            }\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(\\n        address operator,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1686181715", "hash": "0x7e6ae633cc54e92ee3569160fe219cce00f442b21ef5499cc9f7155f2485f812", "contractAddress": "0x8bf0ca07d85c886cd7d56587c0cdc4306f871726", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract GoldenTicket is\\n    ERC721AQueryable,\\n    ERC2981,\\n    Ownable,\\n    Pausable,\\n    DefaultOperatorFilterer\\n{\\n    string private _name;\\n    string private _symbol;\\n    string public baseUri;\\n\\n    mapping(uint256 => bool) private lockedTokens;\\n    mapping(address => bool) public permittedOperators;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        address recipient,\\n        uint96 value\\n    ) ERC721A(_name, _symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice The name of the ERC721 token.\\n    function name()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /// @notice The symbol of the ERC721 token.\\n    function symbol()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /// @notice Sets the name and symbol of the ERC721 token.\\n    /// @param newName The new name for the token.\\n    /// @param newSymbol The new symbol for the token.\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) external onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    /// @notice The token base URI.\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Sets the base URI for the token metadata.\\n    /// @param _baseUri The new base URI for the token metadata.\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Pauses the contract, preventing token transfers.\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses the contract, allowing token transfers.\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n    /// @param to An array of addresses to which tokens will be minted.\\n    /// @param value An array of values representing the number of tokens to mint for each address.\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the royalty fee for the specified recipient.\\n    /// @param recipient The address of the royalty recipient.\\n    /// @param value The value of the royalty fee.\\n    function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice Locks the specified tokens, preventing them from being transferred.\\n    /// @param tokenIds An array of token IDs to be locked.\\n    function lockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(!lockedTokens[tokenIds[i]], \\\"Token is already locked\\\");\\n            lockedTokens[tokenIds[i]] = true;\\n        }\\n    }\\n\\n    /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n    /// @param tokenIds An array of token IDs to be unlocked.\\n    function unlockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(lockedTokens[tokenIds[i]], \\\"Token is already unlocked\\\");\\n            lockedTokens[tokenIds[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Admin function to burn and redeem the golden ticket.\\n    /// @param tokenIds An array of locked token IDs to be burned.\\n    function burnLockedTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                lockedTokens[tokenIds[i]],\\n                \\\"Token must be locked before burning\\\"\\n            );\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Adds multiple addresses as permitted operators.\\n    /// @param operators An array of addresses to be added as permitted operators.\\n    function addPermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            if (!permittedOperators[operators[i]]) {\\n                permittedOperators[operators[i]] = true;\\n            }\\n        }\\n    }\\n\\n    /// @notice Removes multiple addresses from the permitted operators list.\\n    /// @param operators An array of addresses to be removed from the permitted operators list.\\n    function removePermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            permittedOperators[operators[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Retrieves the lock statuses of the specified tokens.\\n    /// @param tokenIds An array of token IDs to check the lock status.\\n    /// @return An array of boolean values representing the lock statuses of the tokens.\\n    function getTokenLockStatuses(\\n        uint256[] memory tokenIds\\n    ) public view returns (bool[] memory) {\\n        bool[] memory lockStatuses = new bool[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lockStatuses[i] = lockedTokens[tokenIds[i]];\\n        }\\n        return lockStatuses;\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (\\n                from != address(0) &&\\n                from != owner() &&\\n                !permittedOperators[from]\\n            ) {\\n                require(\\n                    !lockedTokens[i],\\n                    \\\"Token is locked and cannot be transferred\\\"\\n                );\\n            }\\n            if (lockedTokens[i]) {\\n                require(\\n                    msg.sender == owner() || permittedOperators[msg.sender],\\n                    \\\"Not an allowed operator\\\"\\n                );\\n            }\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(\\n        address operator,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1686180971", "hash": "0x28ce7124f4dd6cdbfef5c77efa0199ada504945248d32251ee0766565f828c92", "contractAddress": "0x8bf0ca07d85c886cd7d56587c0cdc4306f871726", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract GoldenTicket is\\n    ERC721AQueryable,\\n    ERC2981,\\n    Ownable,\\n    Pausable,\\n    DefaultOperatorFilterer\\n{\\n    string private _name;\\n    string private _symbol;\\n    string public baseUri;\\n\\n    mapping(uint256 => bool) private lockedTokens;\\n    mapping(address => bool) public permittedOperators;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        address recipient,\\n        uint96 value\\n    ) ERC721A(_name, _symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice The name of the ERC721 token.\\n    function name()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /// @notice The symbol of the ERC721 token.\\n    function symbol()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /// @notice Sets the name and symbol of the ERC721 token.\\n    /// @param newName The new name for the token.\\n    /// @param newSymbol The new symbol for the token.\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) external onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    /// @notice The token base URI.\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Sets the base URI for the token metadata.\\n    /// @param _baseUri The new base URI for the token metadata.\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Pauses the contract, preventing token transfers.\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses the contract, allowing token transfers.\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n    /// @param to An array of addresses to which tokens will be minted.\\n    /// @param value An array of values representing the number of tokens to mint for each address.\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the royalty fee for the specified recipient.\\n    /// @param recipient The address of the royalty recipient.\\n    /// @param value The value of the royalty fee.\\n    function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice Locks the specified tokens, preventing them from being transferred.\\n    /// @param tokenIds An array of token IDs to be locked.\\n    function lockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(!lockedTokens[tokenIds[i]], \\\"Token is already locked\\\");\\n            lockedTokens[tokenIds[i]] = true;\\n        }\\n    }\\n\\n    /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n    /// @param tokenIds An array of token IDs to be unlocked.\\n    function unlockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(lockedTokens[tokenIds[i]], \\\"Token is already unlocked\\\");\\n            lockedTokens[tokenIds[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Admin function to burn and redeem the golden ticket.\\n    /// @param tokenIds An array of locked token IDs to be burned.\\n    function burnLockedTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                lockedTokens[tokenIds[i]],\\n                \\\"Token must be locked before burning\\\"\\n            );\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Adds multiple addresses as permitted operators.\\n    /// @param operators An array of addresses to be added as permitted operators.\\n    function addPermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            if (!permittedOperators[operators[i]]) {\\n                permittedOperators[operators[i]] = true;\\n            }\\n        }\\n    }\\n\\n    /// @notice Removes multiple addresses from the permitted operators list.\\n    /// @param operators An array of addresses to be removed from the permitted operators list.\\n    function removePermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            permittedOperators[operators[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Retrieves the lock statuses of the specified tokens.\\n    /// @param tokenIds An array of token IDs to check the lock status.\\n    /// @return An array of boolean values representing the lock statuses of the tokens.\\n    function getTokenLockStatuses(\\n        uint256[] memory tokenIds\\n    ) public view returns (bool[] memory) {\\n        bool[] memory lockStatuses = new bool[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lockStatuses[i] = lockedTokens[tokenIds[i]];\\n        }\\n        return lockStatuses;\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (\\n                from != address(0) &&\\n                from != owner() &&\\n                !permittedOperators[from]\\n            ) {\\n                require(\\n                    !lockedTokens[i],\\n                    \\\"Token is locked and cannot be transferred\\\"\\n                );\\n            }\\n            if (lockedTokens[i]) {\\n                require(\\n                    msg.sender == owner() || permittedOperators[msg.sender],\\n                    \\\"Not an allowed operator\\\"\\n                );\\n            }\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(\\n        address operator,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1686179699", "hash": "0xa4b1b7a27afe03ad49b2db7073e60be6e41380eef6822169821354b3bb084950", "contractAddress": "0x8bf0ca07d85c886cd7d56587c0cdc4306f871726", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GoldenTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract GoldenTicket is\\n    ERC721AQueryable,\\n    ERC2981,\\n    Ownable,\\n    Pausable,\\n    DefaultOperatorFilterer\\n{\\n    string private _name;\\n    string private _symbol;\\n    string public baseUri;\\n\\n    mapping(uint256 => bool) private lockedTokens;\\n    mapping(address => bool) public permittedOperators;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        address recipient,\\n        uint96 value\\n    ) ERC721A(_name, _symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice The name of the ERC721 token.\\n    function name()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /// @notice The symbol of the ERC721 token.\\n    function symbol()\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /// @notice Sets the name and symbol of the ERC721 token.\\n    /// @param newName The new name for the token.\\n    /// @param newSymbol The new symbol for the token.\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) external onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    /// @notice The token base URI.\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Sets the base URI for the token metadata.\\n    /// @param _baseUri The new base URI for the token metadata.\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Pauses the contract, preventing token transfers.\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses the contract, allowing token transfers.\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Mints multiple tokens and assigns them to the specified addresses.\\n    /// @param to An array of addresses to which tokens will be minted.\\n    /// @param value An array of values representing the number of tokens to mint for each address.\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        for (uint256 i = 0; i < to.length; i++) {\\n            _mint(to[i], value[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the royalty fee for the specified recipient.\\n    /// @param recipient The address of the royalty recipient.\\n    /// @param value The value of the royalty fee.\\n    function setRoyalties(address recipient, uint96 value) public onlyOwner {\\n        _setDefaultRoyalty(recipient, value);\\n    }\\n\\n    /// @notice Locks the specified tokens, preventing them from being transferred.\\n    /// @param tokenIds An array of token IDs to be locked.\\n    function lockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(!lockedTokens[tokenIds[i]], \\\"Token is already locked\\\");\\n            lockedTokens[tokenIds[i]] = true;\\n        }\\n    }\\n\\n    /// @notice Admin function to unlock the specified golden tickets, allowing them to be transferred.\\n    /// @param tokenIds An array of token IDs to be unlocked.\\n    function unlockTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(lockedTokens[tokenIds[i]], \\\"Token is already unlocked\\\");\\n            lockedTokens[tokenIds[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Admin function to burn and redeem the golden ticket.\\n    /// @param tokenIds An array of locked token IDs to be burned.\\n    function burnLockedTokens(uint256[] memory tokenIds) public {\\n        require(\\n            permittedOperators[msg.sender] || msg.sender == owner(),\\n            \\\"Not an allowed operator\\\"\\n        );\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                lockedTokens[tokenIds[i]],\\n                \\\"Token must be locked before burning\\\"\\n            );\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Adds multiple addresses as permitted operators.\\n    /// @param operators An array of addresses to be added as permitted operators.\\n    function addPermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            if (!permittedOperators[operators[i]]) {\\n                permittedOperators[operators[i]] = true;\\n            }\\n        }\\n    }\\n\\n    /// @notice Removes multiple addresses from the permitted operators list.\\n    /// @param operators An array of addresses to be removed from the permitted operators list.\\n    function removePermittedOperators(\\n        address[] memory operators\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            permittedOperators[operators[i]] = false;\\n        }\\n    }\\n\\n    /// @notice Retrieves the lock statuses of the specified tokens.\\n    /// @param tokenIds An array of token IDs to check the lock status.\\n    /// @return An array of boolean values representing the lock statuses of the tokens.\\n    function getTokenLockStatuses(\\n        uint256[] memory tokenIds\\n    ) public view returns (bool[] memory) {\\n        bool[] memory lockStatuses = new bool[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lockStatuses[i] = lockedTokens[tokenIds[i]];\\n        }\\n        return lockStatuses;\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        for (uint256 i = startTokenId; i < startTokenId + quantity; i++) {\\n            if (\\n                from != address(0) &&\\n                from != owner() &&\\n                !permittedOperators[from]\\n            ) {\\n                require(\\n                    !lockedTokens[i],\\n                    \\\"Token is locked and cannot be transferred\\\"\\n                );\\n            }\\n            if (lockedTokens[i]) {\\n                require(\\n                    msg.sender == owner() || permittedOperators[msg.sender],\\n                    \\\"Not an allowed operator\\\"\\n                );\\n            }\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(\\n        address operator,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        override(ERC721A, IERC721A)\\n        onlyAllowedOperator(from)\\n        whenNotPaused\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1684742267", "hash": "0xf432a06f978ff8a404920737240c81b5b424176c243404d1954f0023c7d3cda1", "contractAddress": "0x276688caba2d9348581b988c5ca09894ca134f93", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AdidasBluePass.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721ABurnable.sol\\\";\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\n\\ncontract AdidasBluePass is ERC721ABurnable, ERC721AQueryable, Ownable {\\n    string private _name;\\n    string private _symbol;\\n    string public contractUri;\\n    string public baseUri;\\n\\n    bool public locked;\\n    bool public uniqueMetadata;\\n\\n    mapping(address => bool) public authorized;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        string memory _contractUri\\n    ) ERC721A(__name, __symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        baseUri = _baseUri;\\n        contractUri = _contractUri;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(\\n            authorized[msg.sender] || owner() == msg.sender,\\n            \\\"Not authorized or owner\\\"\\n        );\\n        _;\\n    }\\n\\n    function name()\\n        public\\n        view\\n        virtual\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    function symbol()\\n        public\\n        view\\n        virtual\\n        override(ERC721A, IERC721A)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    function setNameAndSymbol(\\n        string calldata newName,\\n        string calldata newSymbol\\n    ) public onlyOwner {\\n        _name = newName;\\n        _symbol = newSymbol;\\n    }\\n\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    function setContractUri(string calldata _contractUri) public onlyOwner {\\n        contractUri = _contractUri;\\n    }\\n\\n    function setUniqueMetadata(bool status) public onlyOwner {\\n        uniqueMetadata = status;\\n    }\\n\\n    function mintPass(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        unchecked {\\n            for (uint256 i = 0; i < to.length; i++) {\\n                _mint(to[i], value[i]);\\n            }\\n        }\\n        locked = true;\\n    }\\n\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view override(ERC721A, IERC721A) returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n        string memory base = _baseURI();\\n        if (uniqueMetadata) {\\n            return string(abi.encodePacked(base, _toString(tokenId), \\\".json\\\"));\\n        } else {\\n            return base;\\n        }\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, IERC721A) returns (bool) {\\n        return ERC721A.supportsInterface(interfaceId);\\n    }\\n\\n    function setLocked(bool _locked) external {\\n        locked = _locked;\\n    }\\n\\n    function setAuthorized(address addr, bool status) public onlyOwner {\\n        authorized[addr] = status;\\n    }\\n\\n    function redeemPass(uint256[] memory tokenIds) public onlyAuthorized {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal override {\\n        if (!(authorized[msg.sender] || owner() == msg.sender)) {\\n            require(!locked, \\\"This token is non-transferable\\\");\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721ABurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721ABurnable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721ABurnable.\\n *\\n * @dev ERC721A token that can be irreversibly burned (destroyed).\\n */\\nabstract contract ERC721ABurnable is ERC721A, IERC721ABurnable {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721A-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual override {\\n        _burn(tokenId, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721ABurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721ABurnable.\\n */\\ninterface IERC721ABurnable is IERC721A {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721A-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}, {"protocol": "adidas Originals", "timeStamp": "1684742159", "hash": "0x5bcf5bc1885afea3ce6716c093db555d1d61ae6a8150db6c1e61cb9ce41a2766", "contractAddress": "0xc778e11492cf9d44c9ffc074648a34897e4664cb", "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/AdidasBluePass.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./ERC721A.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\n\\ncontract AdidasBluePass is ERC721A, ERC2981, Ownable {\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Token symbol\\n    uint256 private _maxSupply;\\n\\n    // Base uri\\n    string public baseUri = \\\"\\\";\\n\\n    // Blocking transactions\\n    bool private locked = false;\\n\\n    // Authorized operators\\n    mapping(address => bool) public authorized;\\n\\n    // Unique metadata per token\\n    bool public uniqueMetadata;\\n\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        string memory _baseUri,\\n        uint256 __maxSupply\\n    ) ERC721A(__name, __symbol) {\\n        _name = __name;\\n        _symbol = __symbol;\\n        _maxSupply = __maxSupply;\\n        baseUri = _baseUri;\\n        _setDefaultRoyalty(msg.sender, 0);\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(\\n            authorized[msg.sender] || owner() == msg.sender,\\n            \\\"Not authorized or owner\\\"\\n        );\\n        _;\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function maxSupply() public view returns (uint256) {\\n        return _maxSupply;\\n    }\\n\\n    function isLocked() public view returns (bool) {\\n        return locked;\\n    }\\n\\n    function setNameAndSymbol(\\n        string calldata __name,\\n        string calldata __symbol\\n    ) public onlyOwner {\\n        _name = __name;\\n        _symbol = __symbol;\\n    }\\n\\n    // baseURI\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /**\\n     * @param _baseUri sets the new baseUri\\n     */\\n    function setBaseUri(string calldata _baseUri) public onlyOwner {\\n        baseUri = _baseUri;\\n    }\\n\\n    function setUniqueMetadata(bool status) public onlyOwner {\\n        uniqueMetadata = status;\\n    }\\n\\n    /**\\n     * @param to array of destination addresses\\n     * @param value the amount of tokens to minted\\n     */\\n    function mintMany(\\n        address[] calldata to,\\n        uint256[] calldata value\\n    ) external onlyOwner {\\n        require(to.length == value.length, \\\"Mismatched lengths\\\");\\n        uint256 count = to.length;\\n        unchecked {\\n            for (uint256 i = 0; i < count; ) {\\n                // mint value amount for to address\\n                uint256 newMax = _totalMinted() + value[i];\\n                require(_maxSupply >= newMax, \\\"Max supply reached\\\");\\n                _mint(to[i], value[i]);\\n                i++;\\n            }\\n        }\\n        locked = true;\\n    }\\n\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n        string memory base = _baseURI();\\n        if (uniqueMetadata) {\\n            return string(abi.encodePacked(base, _toString(tokenId), \\\".json\\\"));\\n        } else {\\n            return base;\\n        }\\n    }\\n\\n    // Interface Support\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721A, ERC2981) returns (bool) {\\n        return\\n            ERC721A.supportsInterface(interfaceId) ||\\n            ERC2981.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @param _locked enables/disables Transfers\\n     */\\n    function setLocked(bool _locked) external {\\n        locked = _locked;\\n    }\\n\\n    function setAuthorized(address addr, bool status) public onlyOwner {\\n        authorized[addr] = status;\\n    }\\n\\n    function burn(uint256 tokenId) public {\\n        require(\\n            ownerOf(tokenId) == msg.sender,\\n            \\\"Caller is not the token owner\\\"\\n        );\\n        _burn(tokenId);\\n    }\\n\\n    function burnByOperator(uint256[] memory tokenIds) public onlyAuthorized {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            _burn(tokenIds[i]);\\n        }\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal override {\\n        if (!authorized[msg.sender]) {\\n            require(!locked, \\\"This token is non-transferable\\\");\\n        }\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {\\n        if (_startTokenId() <= tokenId) {\\n            packed = _packedOwnerships[tokenId];\\n            // If not burned.\\n            if (packed & _BITMASK_BURNED == 0) {\\n                // If the data at the starting slot does not exist, start the scan.\\n                if (packed == 0) {\\n                    if (tokenId >= _currentIndex) revert OwnerQueryForNonexistentToken();\\n                    // Invariant:\\n                    // There will always be an initialized ownership slot\\n                    // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                    // before an unintialized ownership slot\\n                    // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                    // Hence, `tokenId` will not underflow.\\n                    //\\n                    // We can directly compare the packed value.\\n                    // If the address is zero, packed will be zero.\\n                    for (;;) {\\n                        unchecked {\\n                            packed = _packedOwnerships[--tokenId];\\n                        }\\n                        if (packed == 0) continue;\\n                        return packed;\\n                    }\\n                }\\n                // Otherwise, the data exists and is not burned. We can skip the scan.\\n                // This is possible because we have already achieved the target condition.\\n                // This saves 2143 gas on transfers of initialized tokens.\\n                return packed;\\n            }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        _approve(to, tokenId, true);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                       APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_approve(to, tokenId, false)`.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _approve(to, tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        bool approvalCheck\\n    ) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        if (approvalCheck)\\n            if (_msgSenderERC721A() != owner)\\n                if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                    revert ApprovalCallerNotOwnerNorApproved();\\n                }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}]